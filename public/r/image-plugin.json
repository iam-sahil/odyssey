{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/utils",
    "@lexical/markdown"
  ],
  "registryDependencies": [
    "button",
    "dialog",
    "input",
    "label",
    "select",
    "tabs",
    "@shadcn-editor/toolbar-plugin"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/images-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useEffect, useRef, useState } from \"react\"\nimport * as React from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { $wrapNodeInElement, mergeRegister } from \"@lexical/utils\"\nimport {\n  $createParagraphNode,\n  $createRangeSelection,\n  $getSelection,\n  $insertNodes,\n  $isNodeSelection,\n  $isRootOrShadowRoot,\n  $setSelection,\n  COMMAND_PRIORITY_EDITOR,\n  COMMAND_PRIORITY_HIGH,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  DRAGOVER_COMMAND,\n  DRAGSTART_COMMAND,\n  DROP_COMMAND,\n  LexicalCommand,\n  LexicalEditor,\n} from \"lexical\"\n\nimport {\n  $createImageNode,\n  $isImageNode,\n  ImageNode,\n  ImagePayload,\n} from \"@/registry/new-york-v4/editor/nodes/image-node\"\nimport { CAN_USE_DOM } from \"@/registry/new-york-v4/editor/shared/can-use-dom\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport { DialogFooter } from \"@/registry/new-york-v4/ui/dialog\"\nimport { Input } from \"@/registry/new-york-v4/ui/input\"\nimport { Label } from \"@/registry/new-york-v4/ui/label\"\nimport {\n  Tabs,\n  TabsContent,\n  TabsList,\n  TabsTrigger,\n} from \"@/registry/new-york-v4/ui/tabs\"\n\nexport type InsertImagePayload = Readonly<ImagePayload>\n\nconst getDOMSelection = (targetWindow: Window | null): Selection | null =>\n  CAN_USE_DOM ? (targetWindow || window).getSelection() : null\n\nexport const INSERT_IMAGE_COMMAND: LexicalCommand<InsertImagePayload> =\n  createCommand(\"INSERT_IMAGE_COMMAND\")\n\nexport function InsertImageUriDialogBody({\n  onClick,\n}: {\n  onClick: (payload: InsertImagePayload) => void\n}) {\n  const [src, setSrc] = useState(\"\")\n  const [altText, setAltText] = useState(\"\")\n\n  const isDisabled = src === \"\"\n\n  return (\n    <div className=\"grid gap-4 py-4\">\n      <div className=\"grid gap-2\">\n        <Label htmlFor=\"image-url\">Image URL</Label>\n        <Input\n          id=\"image-url\"\n          placeholder=\"i.e. https://source.unsplash.com/random\"\n          onChange={(e) => setSrc(e.target.value)}\n          value={src}\n          data-test-id=\"image-modal-url-input\"\n        />\n      </div>\n      <div className=\"grid gap-2\">\n        <Label htmlFor=\"alt-text\">Alt Text</Label>\n        <Input\n          id=\"alt-text\"\n          placeholder=\"Random unsplash image\"\n          onChange={(e) => setAltText(e.target.value)}\n          value={altText}\n          data-test-id=\"image-modal-alt-text-input\"\n        />\n      </div>\n      <DialogFooter>\n        <Button\n          type=\"submit\"\n          disabled={isDisabled}\n          onClick={() => onClick({ altText, src })}\n          data-test-id=\"image-modal-confirm-btn\"\n        >\n          Confirm\n        </Button>\n      </DialogFooter>\n    </div>\n  )\n}\n\nexport function InsertImageUploadedDialogBody({\n  onClick,\n}: {\n  onClick: (payload: InsertImagePayload) => void\n}) {\n  const [src, setSrc] = useState(\"\")\n  const [altText, setAltText] = useState(\"\")\n\n  const isDisabled = src === \"\"\n\n  const loadImage = (files: FileList | null) => {\n    const reader = new FileReader()\n    reader.onload = function () {\n      if (typeof reader.result === \"string\") {\n        setSrc(reader.result)\n      }\n      return \"\"\n    }\n    if (files !== null) {\n      reader.readAsDataURL(files[0])\n    }\n  }\n\n  return (\n    <div className=\"grid gap-4 py-4\">\n      <div className=\"grid gap-2\">\n        <Label htmlFor=\"image-upload\">Image Upload</Label>\n        <Input\n          id=\"image-upload\"\n          type=\"file\"\n          onChange={(e) => loadImage(e.target.files)}\n          accept=\"image/*\"\n          data-test-id=\"image-modal-file-upload\"\n        />\n      </div>\n      <div className=\"grid gap-2\">\n        <Label htmlFor=\"alt-text\">Alt Text</Label>\n        <Input\n          id=\"alt-text\"\n          placeholder=\"Descriptive alternative text\"\n          onChange={(e) => setAltText(e.target.value)}\n          value={altText}\n          data-test-id=\"image-modal-alt-text-input\"\n        />\n      </div>\n      <Button\n        type=\"submit\"\n        disabled={isDisabled}\n        onClick={() => onClick({ altText, src })}\n        data-test-id=\"image-modal-file-upload-btn\"\n      >\n        Confirm\n      </Button>\n    </div>\n  )\n}\n\nexport function InsertImageDialog({\n  activeEditor,\n  onClose,\n}: {\n  activeEditor: LexicalEditor\n  onClose: () => void\n}): JSX.Element {\n  const hasModifier = useRef(false)\n\n  useEffect(() => {\n    hasModifier.current = false\n    const handler = (e: KeyboardEvent) => {\n      hasModifier.current = e.altKey\n    }\n    document.addEventListener(\"keydown\", handler)\n    return () => {\n      document.removeEventListener(\"keydown\", handler)\n    }\n  }, [activeEditor])\n\n  const onClick = (payload: InsertImagePayload) => {\n    activeEditor.dispatchCommand(INSERT_IMAGE_COMMAND, payload)\n    onClose()\n  }\n\n  return (\n    <Tabs defaultValue=\"url\">\n      <TabsList className=\"w-full\">\n        <TabsTrigger value=\"url\" className=\"w-full\">\n          URL\n        </TabsTrigger>\n        <TabsTrigger value=\"file\" className=\"w-full\">\n          File\n        </TabsTrigger>\n      </TabsList>\n      <TabsContent value=\"url\">\n        <InsertImageUriDialogBody onClick={onClick} />\n      </TabsContent>\n      <TabsContent value=\"file\">\n        <InsertImageUploadedDialogBody onClick={onClick} />\n      </TabsContent>\n    </Tabs>\n  )\n}\n\nexport function ImagesPlugin({\n  captionsEnabled,\n}: {\n  captionsEnabled?: boolean\n}): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (!editor.hasNodes([ImageNode])) {\n      throw new Error(\"ImagesPlugin: ImageNode not registered on editor\")\n    }\n\n    return mergeRegister(\n      editor.registerCommand<InsertImagePayload>(\n        INSERT_IMAGE_COMMAND,\n        (payload) => {\n          const imageNode = $createImageNode(payload)\n          $insertNodes([imageNode])\n          if ($isRootOrShadowRoot(imageNode.getParentOrThrow())) {\n            $wrapNodeInElement(imageNode, $createParagraphNode).selectEnd()\n          }\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR\n      ),\n      editor.registerCommand<DragEvent>(\n        DRAGSTART_COMMAND,\n        (event) => {\n          return $onDragStart(event)\n        },\n        COMMAND_PRIORITY_HIGH\n      ),\n      editor.registerCommand<DragEvent>(\n        DRAGOVER_COMMAND,\n        (event) => {\n          return $onDragover(event)\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand<DragEvent>(\n        DROP_COMMAND,\n        (event) => {\n          return $onDrop(event, editor)\n        },\n        COMMAND_PRIORITY_HIGH\n      )\n    )\n  }, [captionsEnabled, editor])\n\n  return null\n}\n\nfunction $onDragStart(event: DragEvent): boolean {\n  const node = $getImageNodeInSelection()\n  if (!node) {\n    return false\n  }\n  const dataTransfer = event.dataTransfer\n  if (!dataTransfer) {\n    return false\n  }\n  const TRANSPARENT_IMAGE =\n    \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n  const img = document.createElement(\"img\")\n  img.src = TRANSPARENT_IMAGE\n  dataTransfer.setData(\"text/plain\", \"_\")\n  dataTransfer.setDragImage(img, 0, 0)\n  dataTransfer.setData(\n    \"application/x-lexical-drag\",\n    JSON.stringify({\n      data: {\n        altText: node.__altText,\n        caption: node.__caption,\n        height: node.__height,\n        key: node.getKey(),\n        maxWidth: node.__maxWidth,\n        showCaption: node.__showCaption,\n        src: node.__src,\n        width: node.__width,\n      },\n      type: \"image\",\n    })\n  )\n\n  return true\n}\n\nfunction $onDragover(event: DragEvent): boolean {\n  const node = $getImageNodeInSelection()\n  if (!node) {\n    return false\n  }\n  if (!canDropImage(event)) {\n    event.preventDefault()\n  }\n  return true\n}\n\nfunction $onDrop(event: DragEvent, editor: LexicalEditor): boolean {\n  const node = $getImageNodeInSelection()\n  if (!node) {\n    return false\n  }\n  const data = getDragImageData(event)\n  if (!data) {\n    return false\n  }\n  event.preventDefault()\n  if (canDropImage(event)) {\n    const range = getDragSelection(event)\n    node.remove()\n    const rangeSelection = $createRangeSelection()\n    if (range !== null && range !== undefined) {\n      rangeSelection.applyDOMRange(range)\n    }\n    $setSelection(rangeSelection)\n    editor.dispatchCommand(INSERT_IMAGE_COMMAND, data)\n  }\n  return true\n}\n\nfunction $getImageNodeInSelection(): ImageNode | null {\n  const selection = $getSelection()\n  if (!$isNodeSelection(selection)) {\n    return null\n  }\n  const nodes = selection.getNodes()\n  const node = nodes[0]\n  return $isImageNode(node) ? node : null\n}\n\nfunction getDragImageData(event: DragEvent): null | InsertImagePayload {\n  const dragData = event.dataTransfer?.getData(\"application/x-lexical-drag\")\n  if (!dragData) {\n    return null\n  }\n  const { type, data } = JSON.parse(dragData)\n  if (type !== \"image\") {\n    return null\n  }\n\n  return data\n}\n\ndeclare global {\n  interface DragEvent {\n    rangeOffset?: number\n    rangeParent?: Node\n  }\n}\n\nfunction canDropImage(event: DragEvent): boolean {\n  const target = event.target\n  return !!(\n    target &&\n    target instanceof HTMLElement &&\n    !target.closest(\"code, span.editor-image\") &&\n    target.parentElement &&\n    target.parentElement.closest(\"div.ContentEditable__root\")\n  )\n}\n\nfunction getDragSelection(event: DragEvent): Range | null | undefined {\n  let range\n  const target = event.target as null | Element | Document\n  const targetWindow =\n    target == null\n      ? null\n      : target.nodeType === 9\n        ? (target as Document).defaultView\n        : (target as Element).ownerDocument.defaultView\n  const domSelection = getDOMSelection(targetWindow)\n  if (document.caretRangeFromPoint) {\n    range = document.caretRangeFromPoint(event.clientX, event.clientY)\n  } else if (event.rangeParent && domSelection !== null) {\n    domSelection.collapse(event.rangeParent, event.rangeOffset || 0)\n    range = domSelection.getRangeAt(0)\n  } else {\n    throw Error(`Cannot get the selection when dragging`)\n  }\n\n  return range\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/images-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/image-node.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, Suspense } from \"react\"\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedEditor,\n  SerializedLexicalNode,\n  Spread,\n} from \"lexical\"\nimport { $applyNodeReplacement, createEditor, DecoratorNode } from \"lexical\"\n\nconst ImageComponent = React.lazy(() => import(\"../editor-ui/image-component\"))\n\nexport interface ImagePayload {\n  altText: string\n  caption?: LexicalEditor\n  height?: number\n  key?: NodeKey\n  maxWidth?: number\n  showCaption?: boolean\n  src: string\n  width?: number\n  captionsEnabled?: boolean\n}\n\nfunction isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\n  return (\n    img.parentElement != null &&\n    img.parentElement.tagName === \"LI\" &&\n    img.previousSibling === null &&\n    img.getAttribute(\"aria-roledescription\") === \"checkbox\"\n  )\n}\n\nfunction $convertImageElement(domNode: Node): null | DOMConversionOutput {\n  const img = domNode as HTMLImageElement\n  if (img.src.startsWith(\"file:///\") || isGoogleDocCheckboxImg(img)) {\n    return null\n  }\n  const { alt: altText, src, width, height } = img\n  const node = $createImageNode({ altText, height, src, width })\n  return { node }\n}\n\nexport type SerializedImageNode = Spread<\n  {\n    altText: string\n    caption: SerializedEditor\n    height?: number\n    maxWidth: number\n    showCaption: boolean\n    src: string\n    width?: number\n  },\n  SerializedLexicalNode\n>\n\nexport class ImageNode extends DecoratorNode<JSX.Element> {\n  __src: string\n  __altText: string\n  __width: \"inherit\" | number\n  __height: \"inherit\" | number\n  __maxWidth: number\n  __showCaption: boolean\n  __caption: LexicalEditor\n  // Captions cannot yet be used within editor cells\n  __captionsEnabled: boolean\n\n  static getType(): string {\n    return \"image\"\n  }\n\n  static clone(node: ImageNode): ImageNode {\n    return new ImageNode(\n      node.__src,\n      node.__altText,\n      node.__maxWidth,\n      node.__width,\n      node.__height,\n      node.__showCaption,\n      node.__caption,\n      node.__captionsEnabled,\n      node.__key\n    )\n  }\n\n  static importJSON(serializedNode: SerializedImageNode): ImageNode {\n    const { altText, height, width, maxWidth, caption, src, showCaption } =\n      serializedNode\n    const node = $createImageNode({\n      altText,\n      height,\n      maxWidth,\n      showCaption,\n      src,\n      width,\n    })\n    const nestedEditor = node.__caption\n    const editorState = nestedEditor.parseEditorState(caption.editorState)\n    if (!editorState.isEmpty()) {\n      nestedEditor.setEditorState(editorState)\n    }\n    return node\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement(\"img\")\n    element.setAttribute(\"src\", this.__src)\n    element.setAttribute(\"alt\", this.__altText)\n    element.setAttribute(\"width\", this.__width.toString())\n    element.setAttribute(\"height\", this.__height.toString())\n    return { element }\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      img: (node: Node) => ({\n        conversion: $convertImageElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  constructor(\n    src: string,\n    altText: string,\n    maxWidth: number,\n    width?: \"inherit\" | number,\n    height?: \"inherit\" | number,\n    showCaption?: boolean,\n    caption?: LexicalEditor,\n    captionsEnabled?: boolean,\n    key?: NodeKey\n  ) {\n    super(key)\n    this.__src = src\n    this.__altText = altText\n    this.__maxWidth = maxWidth\n    this.__width = width || \"inherit\"\n    this.__height = height || \"inherit\"\n    this.__showCaption = showCaption || false\n    this.__caption =\n      caption ||\n      createEditor({\n        nodes: [],\n      })\n    this.__captionsEnabled = captionsEnabled || captionsEnabled === undefined\n  }\n\n  exportJSON(): SerializedImageNode {\n    return {\n      altText: this.getAltText(),\n      caption: this.__caption.toJSON(),\n      height: this.__height === \"inherit\" ? 0 : this.__height,\n      maxWidth: this.__maxWidth,\n      showCaption: this.__showCaption,\n      src: this.getSrc(),\n      type: \"image\",\n      version: 1,\n      width: this.__width === \"inherit\" ? 0 : this.__width,\n    }\n  }\n\n  setWidthAndHeight(\n    width: \"inherit\" | number,\n    height: \"inherit\" | number\n  ): void {\n    const writable = this.getWritable()\n    writable.__width = width\n    writable.__height = height\n  }\n\n  setShowCaption(showCaption: boolean): void {\n    const writable = this.getWritable()\n    writable.__showCaption = showCaption\n  }\n\n  // View\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const span = document.createElement(\"span\")\n    const theme = config.theme\n    const className = theme.image\n    if (className !== undefined) {\n      span.className = className\n    }\n    return span\n  }\n\n  updateDOM(): false {\n    return false\n  }\n\n  getSrc(): string {\n    return this.__src\n  }\n\n  getAltText(): string {\n    return this.__altText\n  }\n\n  decorate(): JSX.Element {\n    return (\n      <Suspense fallback={null}>\n        <ImageComponent\n          src={this.__src}\n          altText={this.__altText}\n          width={this.__width}\n          height={this.__height}\n          maxWidth={this.__maxWidth}\n          nodeKey={this.getKey()}\n          showCaption={this.__showCaption}\n          caption={this.__caption}\n          captionsEnabled={this.__captionsEnabled}\n          resizable={true}\n        />\n      </Suspense>\n    )\n  }\n}\n\nexport function $createImageNode({\n  altText,\n  height,\n  maxWidth = 500,\n  captionsEnabled,\n  src,\n  width,\n  showCaption,\n  caption,\n  key,\n}: ImagePayload): ImageNode {\n  return $applyNodeReplacement(\n    new ImageNode(\n      src,\n      altText,\n      maxWidth,\n      width,\n      height,\n      showCaption,\n      caption,\n      captionsEnabled,\n      key\n    )\n  )\n}\n\nexport function $isImageNode(\n  node: LexicalNode | null | undefined\n): node is ImageNode {\n  return node instanceof ImageNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/image-node.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-ui/image-component.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, Suspense, useCallback, useEffect, useRef, useState } from \"react\"\nimport { AutoFocusPlugin } from \"@lexical/react/LexicalAutoFocusPlugin\"\nimport { useCollaborationContext } from \"@lexical/react/LexicalCollaborationContext\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { LexicalErrorBoundary } from \"@lexical/react/LexicalErrorBoundary\"\nimport { HistoryPlugin } from \"@lexical/react/LexicalHistoryPlugin\"\nimport { LexicalNestedComposer } from \"@lexical/react/LexicalNestedComposer\"\nimport { RichTextPlugin } from \"@lexical/react/LexicalRichTextPlugin\"\nimport { useLexicalEditable } from \"@lexical/react/useLexicalEditable\"\nimport { useLexicalNodeSelection } from \"@lexical/react/useLexicalNodeSelection\"\nimport { mergeRegister } from \"@lexical/utils\"\nimport type {\n  BaseSelection,\n  LexicalCommand,\n  LexicalEditor,\n  NodeKey,\n} from \"lexical\"\nimport {\n  $getNodeByKey,\n  $getSelection,\n  $isNodeSelection,\n  $isRangeSelection,\n  $setSelection,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  DRAGSTART_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  KEY_ENTER_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  ParagraphNode,\n  RootNode,\n  SELECTION_CHANGE_COMMAND,\n  TextNode,\n} from \"lexical\"\n\n// import brokenImage from '@/registry/new-york-v4/editor/images/image-broken.svg';\nimport { ContentEditable } from \"@/registry/new-york-v4/editor/editor-ui/content-editable\"\nimport { ImageResizer } from \"@/registry/new-york-v4/editor/editor-ui/image-resizer\"\nimport { $isImageNode } from \"@/registry/new-york-v4/editor/nodes/image-node\"\n\nconst imageCache = new Set()\n\nexport const RIGHT_CLICK_IMAGE_COMMAND: LexicalCommand<MouseEvent> =\n  createCommand(\"RIGHT_CLICK_IMAGE_COMMAND\")\n\nfunction useSuspenseImage(src: string) {\n  if (!imageCache.has(src)) {\n    throw new Promise((resolve) => {\n      const img = new Image()\n      img.src = src\n      img.onload = () => {\n        imageCache.add(src)\n        resolve(null)\n      }\n      img.onerror = () => {\n        imageCache.add(src)\n      }\n    })\n  }\n}\n\nfunction LazyImage({\n  altText,\n  className,\n  imageRef,\n  src,\n  width,\n  height,\n  maxWidth,\n  onError,\n}: {\n  altText: string\n  className: string | null\n  height: \"inherit\" | number\n  imageRef: { current: null | HTMLImageElement }\n  maxWidth: number\n  src: string\n  width: \"inherit\" | number\n  onError: () => void\n}): JSX.Element {\n  useSuspenseImage(src)\n  return (\n    <img\n      className={className || undefined}\n      src={src}\n      alt={altText}\n      ref={imageRef}\n      style={{\n        height,\n        maxWidth,\n        width,\n      }}\n      onError={onError}\n      draggable=\"false\"\n    />\n  )\n}\n\nfunction BrokenImage(): JSX.Element {\n  return (\n    <img\n      src={\"\"}\n      style={{\n        height: 200,\n        opacity: 0.2,\n        width: 200,\n      }}\n      draggable=\"false\"\n    />\n  )\n}\n\nexport default function ImageComponent({\n  src,\n  altText,\n  nodeKey,\n  width,\n  height,\n  maxWidth,\n  resizable,\n  showCaption,\n  caption,\n  captionsEnabled,\n}: {\n  altText: string\n  caption: LexicalEditor\n  height: \"inherit\" | number\n  maxWidth: number\n  nodeKey: NodeKey\n  resizable: boolean\n  showCaption: boolean\n  src: string\n  width: \"inherit\" | number\n  captionsEnabled: boolean\n}): JSX.Element {\n  const imageRef = useRef<null | HTMLImageElement>(null)\n  const buttonRef = useRef<HTMLButtonElement | null>(null)\n  const [isSelected, setSelected, clearSelection] =\n    useLexicalNodeSelection(nodeKey)\n  const [isResizing, setIsResizing] = useState<boolean>(false)\n  const { isCollabActive } = useCollaborationContext()\n  const [editor] = useLexicalComposerContext()\n  const [selection, setSelection] = useState<BaseSelection | null>(null)\n  const activeEditorRef = useRef<LexicalEditor | null>(null)\n  const [isLoadError, setIsLoadError] = useState<boolean>(false)\n  const isEditable = useLexicalEditable()\n\n  const $onDelete = useCallback(\n    (payload: KeyboardEvent) => {\n      const deleteSelection = $getSelection()\n      if (isSelected && $isNodeSelection(deleteSelection)) {\n        const event: KeyboardEvent = payload\n        event.preventDefault()\n        editor.update(() => {\n          deleteSelection.getNodes().forEach((node) => {\n            if ($isImageNode(node)) {\n              node.remove()\n            }\n          })\n        })\n      }\n      return false\n    },\n    [editor, isSelected]\n  )\n\n  const $onEnter = useCallback(\n    (event: KeyboardEvent) => {\n      const latestSelection = $getSelection()\n      const buttonElem = buttonRef.current\n      if (\n        isSelected &&\n        $isNodeSelection(latestSelection) &&\n        latestSelection.getNodes().length === 1\n      ) {\n        if (showCaption) {\n          // Move focus into nested editor\n          $setSelection(null)\n          event.preventDefault()\n          caption.focus()\n          return true\n        } else if (\n          buttonElem !== null &&\n          buttonElem !== document.activeElement\n        ) {\n          event.preventDefault()\n          buttonElem.focus()\n          return true\n        }\n      }\n      return false\n    },\n    [caption, isSelected, showCaption]\n  )\n\n  const $onEscape = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        activeEditorRef.current === caption ||\n        buttonRef.current === event.target\n      ) {\n        $setSelection(null)\n        editor.update(() => {\n          setSelected(true)\n          const parentRootElement = editor.getRootElement()\n          if (parentRootElement !== null) {\n            parentRootElement.focus()\n          }\n        })\n        return true\n      }\n      return false\n    },\n    [caption, editor, setSelected]\n  )\n\n  const onClick = useCallback(\n    (payload: MouseEvent) => {\n      const event = payload\n\n      if (isResizing) {\n        return true\n      }\n      if (event.target === imageRef.current) {\n        if (event.shiftKey) {\n          setSelected(!isSelected)\n        } else {\n          clearSelection()\n          setSelected(true)\n        }\n        return true\n      }\n\n      return false\n    },\n    [isResizing, isSelected, setSelected, clearSelection]\n  )\n\n  const onRightClick = useCallback(\n    (event: MouseEvent): void => {\n      editor.getEditorState().read(() => {\n        const latestSelection = $getSelection()\n        const domElement = event.target as HTMLElement\n        if (\n          domElement.tagName === \"IMG\" &&\n          $isRangeSelection(latestSelection) &&\n          latestSelection.getNodes().length === 1\n        ) {\n          editor.dispatchCommand(RIGHT_CLICK_IMAGE_COMMAND, event as MouseEvent)\n        }\n      })\n    },\n    [editor]\n  )\n\n  useEffect(() => {\n    let isMounted = true\n    const rootElement = editor.getRootElement()\n    const unregister = mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        if (isMounted) {\n          setSelection(editorState.read(() => $getSelection()))\n        }\n      }),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        (_, activeEditor) => {\n          activeEditorRef.current = activeEditor\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand<MouseEvent>(\n        CLICK_COMMAND,\n        onClick,\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand<MouseEvent>(\n        RIGHT_CLICK_IMAGE_COMMAND,\n        onClick,\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        DRAGSTART_COMMAND,\n        (event) => {\n          if (event.target === imageRef.current) {\n            // TODO This is just a temporary workaround for FF to behave like other browsers.\n            // Ideally, this handles drag & drop too (and all browsers).\n            event.preventDefault()\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        KEY_DELETE_COMMAND,\n        $onDelete,\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        KEY_BACKSPACE_COMMAND,\n        $onDelete,\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(KEY_ENTER_COMMAND, $onEnter, COMMAND_PRIORITY_LOW),\n      editor.registerCommand(\n        KEY_ESCAPE_COMMAND,\n        $onEscape,\n        COMMAND_PRIORITY_LOW\n      )\n    )\n\n    rootElement?.addEventListener(\"contextmenu\", onRightClick)\n\n    return () => {\n      isMounted = false\n      unregister()\n      rootElement?.removeEventListener(\"contextmenu\", onRightClick)\n    }\n  }, [\n    clearSelection,\n    editor,\n    isResizing,\n    isSelected,\n    nodeKey,\n    $onDelete,\n    $onEnter,\n    $onEscape,\n    onClick,\n    onRightClick,\n    setSelected,\n  ])\n\n  const setShowCaption = () => {\n    editor.update(() => {\n      const node = $getNodeByKey(nodeKey)\n      if ($isImageNode(node)) {\n        node.setShowCaption(true)\n      }\n    })\n  }\n\n  const onResizeEnd = (\n    nextWidth: \"inherit\" | number,\n    nextHeight: \"inherit\" | number\n  ) => {\n    // Delay hiding the resize bars for click case\n    setTimeout(() => {\n      setIsResizing(false)\n    }, 200)\n\n    editor.update(() => {\n      const node = $getNodeByKey(nodeKey)\n      if ($isImageNode(node)) {\n        node.setWidthAndHeight(nextWidth, nextHeight)\n      }\n    })\n  }\n\n  const onResizeStart = () => {\n    setIsResizing(true)\n  }\n\n  const draggable = isSelected && $isNodeSelection(selection) && !isResizing\n  const isFocused = (isSelected || isResizing) && isEditable\n  return (\n    <Suspense fallback={null}>\n      <>\n        <div draggable={draggable}>\n          {isLoadError ? (\n            <BrokenImage />\n          ) : (\n            <LazyImage\n              className={`max-w-full cursor-default ${\n                isFocused\n                  ? `${$isNodeSelection(selection) ? \"draggable cursor-grab active:cursor-grabbing\" : \"\"} focused ring-primary ring-2 ring-offset-2`\n                  : null\n              }`}\n              src={src}\n              altText={altText}\n              imageRef={imageRef}\n              width={width}\n              height={height}\n              maxWidth={maxWidth}\n              onError={() => setIsLoadError(true)}\n            />\n          )}\n        </div>\n\n        {showCaption && (\n          <div className=\"image-caption-container absolute right-0 bottom-1 left-0 m-0 block min-w-[100px] overflow-hidden border-t bg-white/90 p-0\">\n            <LexicalNestedComposer\n              initialEditor={caption}\n              initialNodes={[RootNode, TextNode, ParagraphNode]}\n            >\n              <AutoFocusPlugin />\n              <HistoryPlugin />\n              <RichTextPlugin\n                contentEditable={\n                  <ContentEditable\n                    className=\"ImageNode__contentEditable user-select-text word-break-break-word caret-primary relative block min-h-5 w-[calc(100%-20px)] cursor-text resize-none border-0 p-2.5 text-sm whitespace-pre-wrap outline-none\"\n                    placeholderClassName=\"ImageNode__placeholder text-sm text-muted-foreground overflow-hidden absolute top-2.5 left-2.5 pointer-events-none text-ellipsis user-select-none whitespace-nowrap inline-block\"\n                    placeholder=\"Enter a caption...\"\n                  />\n                }\n                ErrorBoundary={LexicalErrorBoundary}\n              />\n            </LexicalNestedComposer>\n          </div>\n        )}\n        {resizable && $isNodeSelection(selection) && isFocused && (\n          <ImageResizer\n            showCaption={showCaption}\n            setShowCaption={setShowCaption}\n            editor={editor}\n            buttonRef={buttonRef}\n            imageRef={imageRef}\n            maxWidth={maxWidth}\n            onResizeStart={onResizeStart}\n            onResizeEnd={onResizeEnd}\n            captionsEnabled={!isLoadError && captionsEnabled}\n          />\n        )}\n      </>\n    </Suspense>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-ui/image-component.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-ui/image-resizer.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, useRef } from \"react\"\nimport { calculateZoomLevel } from \"@lexical/utils\"\nimport type { LexicalEditor } from \"lexical\"\n\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\nconst Direction = {\n  east: 1 << 0,\n  north: 1 << 3,\n  south: 1 << 1,\n  west: 1 << 2,\n}\n\nexport function ImageResizer({\n  onResizeStart,\n  onResizeEnd,\n  buttonRef,\n  imageRef,\n  maxWidth,\n  editor,\n  showCaption,\n  setShowCaption,\n  captionsEnabled,\n}: {\n  editor: LexicalEditor\n  buttonRef: { current: null | HTMLButtonElement }\n  imageRef: { current: null | HTMLElement }\n  maxWidth?: number\n  onResizeEnd: (width: \"inherit\" | number, height: \"inherit\" | number) => void\n  onResizeStart: () => void\n  setShowCaption: (show: boolean) => void\n  showCaption: boolean\n  captionsEnabled: boolean\n}): JSX.Element {\n  const controlWrapperRef = useRef<HTMLDivElement>(null)\n  const userSelect = useRef({\n    priority: \"\",\n    value: \"default\",\n  })\n  const positioningRef = useRef<{\n    currentHeight: \"inherit\" | number\n    currentWidth: \"inherit\" | number\n    direction: number\n    isResizing: boolean\n    ratio: number\n    startHeight: number\n    startWidth: number\n    startX: number\n    startY: number\n  }>({\n    currentHeight: 0,\n    currentWidth: 0,\n    direction: 0,\n    isResizing: false,\n    ratio: 0,\n    startHeight: 0,\n    startWidth: 0,\n    startX: 0,\n    startY: 0,\n  })\n  const editorRootElement = editor.getRootElement()\n  // Find max width, accounting for editor padding.\n  const maxWidthContainer = maxWidth\n    ? maxWidth\n    : editorRootElement !== null\n      ? editorRootElement.getBoundingClientRect().width - 20\n      : 100\n  const maxHeightContainer =\n    editorRootElement !== null\n      ? editorRootElement.getBoundingClientRect().height - 20\n      : 100\n\n  const minWidth = 100\n  const minHeight = 100\n\n  const setStartCursor = (direction: number) => {\n    const ew = direction === Direction.east || direction === Direction.west\n    const ns = direction === Direction.north || direction === Direction.south\n    const nwse =\n      (direction & Direction.north && direction & Direction.west) ||\n      (direction & Direction.south && direction & Direction.east)\n\n    const cursorDir = ew ? \"ew\" : ns ? \"ns\" : nwse ? \"nwse\" : \"nesw\"\n\n    if (editorRootElement !== null) {\n      editorRootElement.style.setProperty(\n        \"cursor\",\n        `${cursorDir}-resize`,\n        \"important\"\n      )\n    }\n    if (document.body !== null) {\n      document.body.style.setProperty(\n        \"cursor\",\n        `${cursorDir}-resize`,\n        \"important\"\n      )\n      userSelect.current.value = document.body.style.getPropertyValue(\n        \"-webkit-user-select\"\n      )\n      userSelect.current.priority = document.body.style.getPropertyPriority(\n        \"-webkit-user-select\"\n      )\n      document.body.style.setProperty(\n        \"-webkit-user-select\",\n        `none`,\n        \"important\"\n      )\n    }\n  }\n\n  const setEndCursor = () => {\n    if (editorRootElement !== null) {\n      editorRootElement.style.setProperty(\"cursor\", \"text\")\n    }\n    if (document.body !== null) {\n      document.body.style.setProperty(\"cursor\", \"default\")\n      document.body.style.setProperty(\n        \"-webkit-user-select\",\n        userSelect.current.value,\n        userSelect.current.priority\n      )\n    }\n  }\n\n  const handlePointerDown = (\n    event: React.PointerEvent<HTMLDivElement>,\n    direction: number\n  ) => {\n    if (!editor.isEditable()) {\n      return\n    }\n\n    const image = imageRef.current\n    const controlWrapper = controlWrapperRef.current\n\n    if (image !== null && controlWrapper !== null) {\n      event.preventDefault()\n      const { width, height } = image.getBoundingClientRect()\n      const zoom = calculateZoomLevel(image)\n      const positioning = positioningRef.current\n      positioning.startWidth = width\n      positioning.startHeight = height\n      positioning.ratio = width / height\n      positioning.currentWidth = width\n      positioning.currentHeight = height\n      positioning.startX = event.clientX / zoom\n      positioning.startY = event.clientY / zoom\n      positioning.isResizing = true\n      positioning.direction = direction\n\n      setStartCursor(direction)\n      onResizeStart()\n\n      controlWrapper.classList.add(\"touch-action-none\")\n      image.style.height = `${height}px`\n      image.style.width = `${width}px`\n\n      document.addEventListener(\"pointermove\", handlePointerMove)\n      document.addEventListener(\"pointerup\", handlePointerUp)\n    }\n  }\n  const handlePointerMove = (event: PointerEvent) => {\n    const image = imageRef.current\n    const positioning = positioningRef.current\n\n    const isHorizontal =\n      positioning.direction & (Direction.east | Direction.west)\n    const isVertical =\n      positioning.direction & (Direction.south | Direction.north)\n\n    if (image !== null && positioning.isResizing) {\n      const zoom = calculateZoomLevel(image)\n      // Corner cursor\n      if (isHorizontal && isVertical) {\n        let diff = Math.floor(positioning.startX - event.clientX / zoom)\n        diff = positioning.direction & Direction.east ? -diff : diff\n\n        const width = clamp(\n          positioning.startWidth + diff,\n          minWidth,\n          maxWidthContainer\n        )\n\n        const height = width / positioning.ratio\n        image.style.width = `${width}px`\n        image.style.height = `${height}px`\n        positioning.currentHeight = height\n        positioning.currentWidth = width\n      } else if (isVertical) {\n        let diff = Math.floor(positioning.startY - event.clientY / zoom)\n        diff = positioning.direction & Direction.south ? -diff : diff\n\n        const height = clamp(\n          positioning.startHeight + diff,\n          minHeight,\n          maxHeightContainer\n        )\n\n        image.style.height = `${height}px`\n        positioning.currentHeight = height\n      } else {\n        let diff = Math.floor(positioning.startX - event.clientX / zoom)\n        diff = positioning.direction & Direction.east ? -diff : diff\n\n        const width = clamp(\n          positioning.startWidth + diff,\n          minWidth,\n          maxWidthContainer\n        )\n\n        image.style.width = `${width}px`\n        positioning.currentWidth = width\n      }\n    }\n  }\n  const handlePointerUp = () => {\n    const image = imageRef.current\n    const positioning = positioningRef.current\n    const controlWrapper = controlWrapperRef.current\n    if (image !== null && controlWrapper !== null && positioning.isResizing) {\n      const width = positioning.currentWidth\n      const height = positioning.currentHeight\n      positioning.startWidth = 0\n      positioning.startHeight = 0\n      positioning.ratio = 0\n      positioning.startX = 0\n      positioning.startY = 0\n      positioning.currentWidth = 0\n      positioning.currentHeight = 0\n      positioning.isResizing = false\n\n      controlWrapper.classList.remove(\"touch-action-none\")\n\n      setEndCursor()\n      onResizeEnd(width, height)\n\n      document.removeEventListener(\"pointermove\", handlePointerMove)\n      document.removeEventListener(\"pointerup\", handlePointerUp)\n    }\n  }\n  return (\n    <div ref={controlWrapperRef}>\n      {!showCaption && captionsEnabled && (\n        <Button\n          className=\"image-caption-button absolute bottom-1 left-1/2 -translate-x-1/2\"\n          ref={buttonRef}\n          variant={\"outline\"}\n          onClick={() => {\n            setShowCaption(!showCaption)\n          }}\n        >\n          Add Caption\n        </Button>\n      )}\n      <div\n        className=\"image-resizer image-resizer-n bg-primary absolute -top-2.5 left-1/2 h-2 w-2 -translate-x-1/2 cursor-ns-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.north)\n        }}\n      />\n      <div\n        className=\"image-resizer image-resizer-ne bg-primary absolute -top-2.5 -right-2.5 h-2 w-2 cursor-nesw-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.north | Direction.east)\n        }}\n      />\n      <div\n        className=\"image-resizer image-resizer-e bg-primary absolute top-1/2 -right-2.5 h-2 w-2 -translate-y-1/2 cursor-ew-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.east)\n        }}\n      />\n      <div\n        className=\"image-resizer image-resizer-se bg-primary absolute -right-2.5 -bottom-2.5 h-2 w-2 cursor-nwse-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.south | Direction.east)\n        }}\n      />\n      <div\n        className=\"image-resizer image-resizer-s bg-primary absolute -bottom-2.5 left-1/2 h-2 w-2 -translate-x-1/2 cursor-ns-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.south)\n        }}\n      />\n      <div\n        className=\"image-resizer image-resizer-sw bg-primary absolute -bottom-2.5 -left-2.5 h-2 w-2 cursor-nesw-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.south | Direction.west)\n        }}\n      />\n      <div\n        className=\"image-resizer image-resizer-w bg-primary absolute top-1/2 -left-2.5 h-2 w-2 -translate-y-1/2 cursor-ew-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.west)\n        }}\n      />\n      <div\n        className=\"image-resizer image-resizer-nw bg-primary absolute -top-2.5 -left-2.5 h-2 w-2 cursor-nwse-resize\"\n        onPointerDown={(event) => {\n          handlePointerDown(event, Direction.north | Direction.west)\n        }}\n      />\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-ui/image-resizer.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/shared/can-use-dom.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport const CAN_USE_DOM: boolean =\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\"\n",
      "type": "registry:component",
      "target": "components/editor/shared/can-use-dom.ts"
    },
    {
      "path": "registry/new-york-v4/editor/transformers/markdown-image-transformer.ts",
      "content": "import { TextMatchTransformer } from \"@lexical/markdown\"\n\nimport {\n  $createImageNode,\n  $isImageNode,\n  ImageNode,\n} from \"@/registry/new-york-v4/editor/nodes/image-node\"\n\nexport const IMAGE: TextMatchTransformer = {\n  dependencies: [ImageNode],\n  export: (node) => {\n    if (!$isImageNode(node)) {\n      return null\n    }\n\n    return `![${node.getAltText()}](${node.getSrc()})`\n  },\n  importRegExp: /!(?:\\[([^[]*)\\])(?:\\(([^(]+)\\))/,\n  regExp: /!(?:\\[([^[]*)\\])(?:\\(([^(]+)\\))$/,\n  replace: (textNode, match) => {\n    const [, altText, src] = match\n    const imageNode = $createImageNode({\n      altText,\n      maxWidth: 800,\n      src,\n    })\n    textNode.replace(imageNode)\n  },\n  trigger: \")\",\n  type: \"text-match\",\n}\n",
      "type": "registry:component",
      "target": "components/editor/transformers/markdown-image-transformer.ts"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert/insert-image.tsx",
      "content": "\"use client\"\n\nimport { ImageIcon } from \"lucide-react\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { InsertImageDialog } from \"@/registry/new-york-v4/editor/plugins/images-plugin\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function InsertImage() {\n  const { activeEditor, showModal } = useToolbarContext()\n\n  return (\n    <SelectItem\n      value=\"image\"\n      onPointerUp={(e) => {\n        showModal(\"Insert Image\", (onClose) => (\n          <InsertImageDialog activeEditor={activeEditor} onClose={onClose} />\n        ))\n      }}\n      className=\"\"\n    >\n      <div className=\"flex items-center gap-1\">\n        <ImageIcon className=\"size-4\" />\n        <span>Image</span>\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-image.tsx"
    }
  ]
}