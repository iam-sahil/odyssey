{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "layout-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/utils"
  ],
  "registryDependencies": [
    "button",
    "select",
    "@shadcn-editor/toolbar-plugin"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/layout-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, useEffect, useState } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport {\n  $findMatchingParent,\n  $insertNodeToNearestRoot,\n  mergeRegister,\n} from \"@lexical/utils\"\nimport {\n  $createParagraphNode,\n  $getNodeByKey,\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_EDITOR,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_LEFT_COMMAND,\n  KEY_ARROW_RIGHT_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  LexicalEditor,\n} from \"lexical\"\nimport type { ElementNode, LexicalCommand, LexicalNode, NodeKey } from \"lexical\"\n\nimport {\n  $createLayoutContainerNode,\n  $isLayoutContainerNode,\n  LayoutContainerNode,\n} from \"@/registry/new-york-v4/editor/nodes/layout-container-node\"\nimport {\n  $createLayoutItemNode,\n  $isLayoutItemNode,\n  LayoutItemNode,\n} from \"@/registry/new-york-v4/editor/nodes/layout-item-node\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/registry/new-york-v4/ui/select\"\n\nconst LAYOUTS = [\n  { label: \"2 columns (equal width)\", value: \"1fr 1fr\" },\n  { label: \"2 columns (25% - 75%)\", value: \"1fr 3fr\" },\n  { label: \"3 columns (equal width)\", value: \"1fr 1fr 1fr\" },\n  { label: \"3 columns (25% - 50% - 25%)\", value: \"1fr 2fr 1fr\" },\n  { label: \"4 columns (equal width)\", value: \"1fr 1fr 1fr 1fr\" },\n]\n\nexport function InsertLayoutDialog({\n  activeEditor,\n  onClose,\n}: {\n  activeEditor: LexicalEditor\n  onClose: () => void\n}): JSX.Element {\n  const [layout, setLayout] = useState(LAYOUTS[0].value)\n  const buttonLabel = LAYOUTS.find((item) => item.value === layout)?.label\n\n  const onClick = () => {\n    activeEditor.dispatchCommand(INSERT_LAYOUT_COMMAND, layout)\n    onClose()\n  }\n\n  return (\n    <>\n      <Select onValueChange={setLayout} defaultValue={layout}>\n        <SelectTrigger className=\"w-full\">\n          <SelectValue placeholder={buttonLabel} />\n        </SelectTrigger>\n        <SelectContent className=\"w-full\">\n          {LAYOUTS.map(({ label, value }) => (\n            <SelectItem key={value} value={value}>\n              {label}\n            </SelectItem>\n          ))}\n        </SelectContent>\n      </Select>\n      <Button onClick={onClick}>Insert</Button>\n    </>\n  )\n}\n\nexport const INSERT_LAYOUT_COMMAND: LexicalCommand<string> =\n  createCommand<string>()\n\nexport const UPDATE_LAYOUT_COMMAND: LexicalCommand<{\n  template: string\n  nodeKey: NodeKey\n}> = createCommand<{ template: string; nodeKey: NodeKey }>()\n\nexport function LayoutPlugin(): null {\n  const [editor] = useLexicalComposerContext()\n  useEffect(() => {\n    if (!editor.hasNodes([LayoutContainerNode, LayoutItemNode])) {\n      throw new Error(\n        \"LayoutPlugin: LayoutContainerNode, or LayoutItemNode not registered on editor\"\n      )\n    }\n\n    const $onEscape = (before: boolean) => {\n      const selection = $getSelection()\n      if (\n        $isRangeSelection(selection) &&\n        selection.isCollapsed() &&\n        selection.anchor.offset === 0\n      ) {\n        const container = $findMatchingParent(\n          selection.anchor.getNode(),\n          $isLayoutContainerNode\n        )\n\n        if ($isLayoutContainerNode(container)) {\n          const parent = container.getParent<ElementNode>()\n          const child =\n            parent &&\n            (before\n              ? parent.getFirstChild<LexicalNode>()\n              : parent?.getLastChild<LexicalNode>())\n          const descendant = before\n            ? container.getFirstDescendant<LexicalNode>()?.getKey()\n            : container.getLastDescendant<LexicalNode>()?.getKey()\n\n          if (\n            parent !== null &&\n            child === container &&\n            selection.anchor.key === descendant\n          ) {\n            if (before) {\n              container.insertBefore($createParagraphNode())\n            } else {\n              container.insertAfter($createParagraphNode())\n            }\n          }\n        }\n      }\n\n      return false\n    }\n\n    return mergeRegister(\n      // When layout is the last child pressing down/right arrow will insert paragraph\n      // below it to allow adding more content. It's similar what $insertBlockNode\n      // (mainly for decorators), except it'll always be possible to continue adding\n      // new content even if trailing paragraph is accidentally deleted\n      editor.registerCommand(\n        KEY_ARROW_DOWN_COMMAND,\n        () => $onEscape(false),\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        KEY_ARROW_RIGHT_COMMAND,\n        () => $onEscape(false),\n        COMMAND_PRIORITY_LOW\n      ),\n      // When layout is the first child pressing up/left arrow will insert paragraph\n      // above it to allow adding more content. It's similar what $insertBlockNode\n      // (mainly for decorators), except it'll always be possible to continue adding\n      // new content even if leading paragraph is accidentally deleted\n      editor.registerCommand(\n        KEY_ARROW_UP_COMMAND,\n        () => $onEscape(true),\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        KEY_ARROW_LEFT_COMMAND,\n        () => $onEscape(true),\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        INSERT_LAYOUT_COMMAND,\n        (template) => {\n          editor.update(() => {\n            const container = $createLayoutContainerNode(template)\n            const itemsCount = getItemsCountFromTemplate(template)\n\n            for (let i = 0; i < itemsCount; i++) {\n              container.append(\n                $createLayoutItemNode().append($createParagraphNode())\n              )\n            }\n\n            $insertNodeToNearestRoot(container)\n            container.selectStart()\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR\n      ),\n      editor.registerCommand(\n        UPDATE_LAYOUT_COMMAND,\n        ({ template, nodeKey }) => {\n          editor.update(() => {\n            const container = $getNodeByKey<LexicalNode>(nodeKey)\n\n            if (!$isLayoutContainerNode(container)) {\n              return\n            }\n\n            const itemsCount = getItemsCountFromTemplate(template)\n            const prevItemsCount = getItemsCountFromTemplate(\n              container.getTemplateColumns()\n            )\n\n            // Add or remove extra columns if new template does not match existing one\n            if (itemsCount > prevItemsCount) {\n              for (let i = prevItemsCount; i < itemsCount; i++) {\n                container.append(\n                  $createLayoutItemNode().append($createParagraphNode())\n                )\n              }\n            } else if (itemsCount < prevItemsCount) {\n              for (let i = prevItemsCount - 1; i >= itemsCount; i--) {\n                const layoutItem = container.getChildAtIndex<LexicalNode>(i)\n\n                if ($isLayoutItemNode(layoutItem)) {\n                  layoutItem.remove()\n                }\n              }\n            }\n\n            container.setTemplateColumns(template)\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR\n      ),\n      // Structure enforcing transformers for each node type. In case nesting structure is not\n      // \"Container > Item\" it'll unwrap nodes and convert it back\n      // to regular content.\n      editor.registerNodeTransform(LayoutItemNode, (node) => {\n        const parent = node.getParent<ElementNode>()\n        if (!$isLayoutContainerNode(parent)) {\n          const children = node.getChildren<LexicalNode>()\n          for (const child of children) {\n            node.insertBefore(child)\n          }\n          node.remove()\n        }\n      }),\n      editor.registerNodeTransform(LayoutContainerNode, (node) => {\n        const children = node.getChildren<LexicalNode>()\n        if (!children.every($isLayoutItemNode)) {\n          for (const child of children) {\n            node.insertBefore(child)\n          }\n          node.remove()\n        }\n      })\n    )\n  }, [editor])\n\n  return null\n}\n\nfunction getItemsCountFromTemplate(template: string): number {\n  return template.trim().split(/\\s+/).length\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/layout-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/layout-container-node.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { addClassNamesToElement } from \"@lexical/utils\"\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalNode,\n  NodeKey,\n  SerializedElementNode,\n  Spread,\n} from \"lexical\"\nimport { ElementNode } from \"lexical\"\n\nexport type SerializedLayoutContainerNode = Spread<\n  {\n    templateColumns: string\n  },\n  SerializedElementNode\n>\n\nfunction $convertLayoutContainerElement(\n  domNode: HTMLElement\n): DOMConversionOutput | null {\n  const styleAttributes = window.getComputedStyle(domNode)\n  const templateColumns = styleAttributes.getPropertyValue(\n    \"grid-template-columns\"\n  )\n  if (templateColumns) {\n    const node = $createLayoutContainerNode(templateColumns)\n    return { node }\n  }\n  return null\n}\n\nexport class LayoutContainerNode extends ElementNode {\n  __templateColumns: string\n\n  constructor(templateColumns: string, key?: NodeKey) {\n    super(key)\n    this.__templateColumns = templateColumns\n  }\n\n  static getType(): string {\n    return \"layout-container\"\n  }\n\n  static clone(node: LayoutContainerNode): LayoutContainerNode {\n    return new LayoutContainerNode(node.__templateColumns, node.__key)\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const dom = document.createElement(\"div\")\n    dom.style.gridTemplateColumns = this.__templateColumns\n    if (typeof config.theme.layoutContainer === \"string\") {\n      addClassNamesToElement(dom, config.theme.layoutContainer)\n    }\n    return dom\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement(\"div\")\n    element.style.gridTemplateColumns = this.__templateColumns\n    element.setAttribute(\"data-lexical-layout-container\", \"true\")\n    return { element }\n  }\n\n  updateDOM(prevNode: LayoutContainerNode, dom: HTMLElement): boolean {\n    if (prevNode.__templateColumns !== this.__templateColumns) {\n      dom.style.gridTemplateColumns = this.__templateColumns\n    }\n    return false\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      div: (domNode: HTMLElement) => {\n        if (!domNode.hasAttribute(\"data-lexical-layout-container\")) {\n          return null\n        }\n        return {\n          conversion: $convertLayoutContainerElement,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  static importJSON(json: SerializedLayoutContainerNode): LayoutContainerNode {\n    return $createLayoutContainerNode(json.templateColumns)\n  }\n\n  isShadowRoot(): boolean {\n    return true\n  }\n\n  canBeEmpty(): boolean {\n    return false\n  }\n\n  exportJSON(): SerializedLayoutContainerNode {\n    return {\n      ...super.exportJSON(),\n      templateColumns: this.__templateColumns,\n      type: \"layout-container\",\n      version: 1,\n    }\n  }\n\n  getTemplateColumns(): string {\n    return this.getLatest().__templateColumns\n  }\n\n  setTemplateColumns(templateColumns: string) {\n    this.getWritable().__templateColumns = templateColumns\n  }\n}\n\nexport function $createLayoutContainerNode(\n  templateColumns: string\n): LayoutContainerNode {\n  return new LayoutContainerNode(templateColumns)\n}\n\nexport function $isLayoutContainerNode(\n  node: LexicalNode | null | undefined\n): node is LayoutContainerNode {\n  return node instanceof LayoutContainerNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/layout-container-node.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/layout-item-node.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { addClassNamesToElement } from \"@lexical/utils\"\nimport type {\n  DOMConversionMap,\n  EditorConfig,\n  LexicalNode,\n  SerializedElementNode,\n} from \"lexical\"\nimport { ElementNode } from \"lexical\"\n\nexport type SerializedLayoutItemNode = SerializedElementNode\n\nexport class LayoutItemNode extends ElementNode {\n  static getType(): string {\n    return \"layout-item\"\n  }\n\n  static clone(node: LayoutItemNode): LayoutItemNode {\n    return new LayoutItemNode(node.__key)\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const dom = document.createElement(\"div\")\n    if (typeof config.theme.layoutItem === \"string\") {\n      addClassNamesToElement(dom, config.theme.layoutItem)\n    }\n    return dom\n  }\n\n  updateDOM(): boolean {\n    return false\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {}\n  }\n\n  static importJSON(): LayoutItemNode {\n    return $createLayoutItemNode()\n  }\n\n  isShadowRoot(): boolean {\n    return true\n  }\n\n  exportJSON(): SerializedLayoutItemNode {\n    return {\n      ...super.exportJSON(),\n      type: \"layout-item\",\n      version: 1,\n    }\n  }\n}\n\nexport function $createLayoutItemNode(): LayoutItemNode {\n  return new LayoutItemNode()\n}\n\nexport function $isLayoutItemNode(\n  node: LexicalNode | null | undefined\n): node is LayoutItemNode {\n  return node instanceof LayoutItemNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/layout-item-node.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert/insert-columns-layout.tsx",
      "content": "\"use client\"\n\nimport { Columns3Icon } from \"lucide-react\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { InsertLayoutDialog } from \"@/registry/new-york-v4/editor/plugins/layout-plugin\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function InsertColumnsLayout() {\n  const { activeEditor, showModal } = useToolbarContext()\n\n  return (\n    <SelectItem\n      value=\"columns\"\n      onPointerUp={() =>\n        showModal(\"Insert Columns Layout\", (onClose) => (\n          <InsertLayoutDialog activeEditor={activeEditor} onClose={onClose} />\n        ))\n      }\n      className=\"\"\n    >\n      <div className=\"flex items-center gap-1\">\n        <Columns3Icon className=\"size-4\" />\n        <span>Columns Layout</span>\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-columns-layout.tsx"
    }
  ]
}