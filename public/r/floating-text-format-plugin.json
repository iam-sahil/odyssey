{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "floating-text-format-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/code",
    "@lexical/link",
    "@lexical/utils",
    "@lexical/selection"
  ],
  "registryDependencies": [
    "separator",
    "toggle-group",
    "@shadcn-editor/rich-text-editor-plugin"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/floating-text-format-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { Dispatch, JSX, useCallback, useEffect, useRef, useState } from \"react\"\nimport * as React from \"react\"\nimport { $isCodeHighlightNode } from \"@lexical/code\"\nimport { $isLinkNode, TOGGLE_LINK_COMMAND } from \"@lexical/link\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { mergeRegister } from \"@lexical/utils\"\nimport {\n  $getSelection,\n  $isParagraphNode,\n  $isRangeSelection,\n  $isTextNode,\n  COMMAND_PRIORITY_LOW,\n  FORMAT_TEXT_COMMAND,\n  LexicalEditor,\n  SELECTION_CHANGE_COMMAND,\n} from \"lexical\"\nimport {\n  BoldIcon,\n  CodeIcon,\n  ItalicIcon,\n  LinkIcon,\n  StrikethroughIcon,\n  SubscriptIcon,\n  SuperscriptIcon,\n  UnderlineIcon,\n} from \"lucide-react\"\nimport { createPortal } from \"react-dom\"\n\nimport { getDOMRangeRect } from \"@/registry/new-york-v4/editor/utils/get-dom-range-rect\"\nimport { getSelectedNode } from \"@/registry/new-york-v4/editor/utils/get-selected-node\"\nimport { setFloatingElemPosition } from \"@/registry/new-york-v4/editor/utils/set-floating-elem-position\"\nimport { Separator } from \"@/registry/new-york-v4/ui/separator\"\nimport {\n  ToggleGroup,\n  ToggleGroupItem,\n} from \"@/registry/new-york-v4/ui/toggle-group\"\n\nfunction FloatingTextFormat({\n  editor,\n  anchorElem,\n  isLink,\n  isBold,\n  isItalic,\n  isUnderline,\n  isCode,\n  isStrikethrough,\n  isSubscript,\n  isSuperscript,\n  setIsLinkEditMode,\n}: {\n  editor: LexicalEditor\n  anchorElem: HTMLElement\n  isBold: boolean\n  isCode: boolean\n  isItalic: boolean\n  isLink: boolean\n  isStrikethrough: boolean\n  isSubscript: boolean\n  isSuperscript: boolean\n  isUnderline: boolean\n  setIsLinkEditMode: Dispatch<boolean>\n}): JSX.Element {\n  const popupCharStylesEditorRef = useRef<HTMLDivElement | null>(null)\n\n  const insertLink = useCallback(() => {\n    if (!isLink) {\n      setIsLinkEditMode(true)\n      editor.dispatchCommand(TOGGLE_LINK_COMMAND, \"https://\")\n    } else {\n      setIsLinkEditMode(false)\n      editor.dispatchCommand(TOGGLE_LINK_COMMAND, null)\n    }\n  }, [editor, isLink, setIsLinkEditMode])\n\n  function mouseMoveListener(e: MouseEvent) {\n    if (\n      popupCharStylesEditorRef?.current &&\n      (e.buttons === 1 || e.buttons === 3)\n    ) {\n      if (popupCharStylesEditorRef.current.style.pointerEvents !== \"none\") {\n        const x = e.clientX\n        const y = e.clientY\n        const elementUnderMouse = document.elementFromPoint(x, y)\n\n        if (!popupCharStylesEditorRef.current.contains(elementUnderMouse)) {\n          // Mouse is not over the target element => not a normal click, but probably a drag\n          popupCharStylesEditorRef.current.style.pointerEvents = \"none\"\n        }\n      }\n    }\n  }\n  function mouseUpListener(e: MouseEvent) {\n    if (popupCharStylesEditorRef?.current) {\n      if (popupCharStylesEditorRef.current.style.pointerEvents !== \"auto\") {\n        popupCharStylesEditorRef.current.style.pointerEvents = \"auto\"\n      }\n    }\n  }\n\n  useEffect(() => {\n    if (popupCharStylesEditorRef?.current) {\n      document.addEventListener(\"mousemove\", mouseMoveListener)\n      document.addEventListener(\"mouseup\", mouseUpListener)\n\n      return () => {\n        document.removeEventListener(\"mousemove\", mouseMoveListener)\n        document.removeEventListener(\"mouseup\", mouseUpListener)\n      }\n    }\n  }, [popupCharStylesEditorRef])\n\n  const $updateTextFormatFloatingToolbar = useCallback(() => {\n    const selection = $getSelection()\n\n    const popupCharStylesEditorElem = popupCharStylesEditorRef.current\n    const nativeSelection = window.getSelection()\n\n    if (popupCharStylesEditorElem === null) {\n      return\n    }\n\n    const rootElement = editor.getRootElement()\n    if (\n      selection !== null &&\n      nativeSelection !== null &&\n      !nativeSelection.isCollapsed &&\n      rootElement !== null &&\n      rootElement.contains(nativeSelection.anchorNode)\n    ) {\n      const rangeRect = getDOMRangeRect(nativeSelection, rootElement)\n\n      setFloatingElemPosition(\n        rangeRect,\n        popupCharStylesEditorElem,\n        anchorElem,\n        isLink\n      )\n    }\n  }, [editor, anchorElem, isLink])\n\n  useEffect(() => {\n    const scrollerElem = anchorElem.parentElement\n\n    const update = () => {\n      editor.getEditorState().read(() => {\n        $updateTextFormatFloatingToolbar()\n      })\n    }\n\n    window.addEventListener(\"resize\", update)\n    if (scrollerElem) {\n      scrollerElem.addEventListener(\"scroll\", update)\n    }\n\n    return () => {\n      window.removeEventListener(\"resize\", update)\n      if (scrollerElem) {\n        scrollerElem.removeEventListener(\"scroll\", update)\n      }\n    }\n  }, [editor, $updateTextFormatFloatingToolbar, anchorElem])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      $updateTextFormatFloatingToolbar()\n    })\n    return mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(() => {\n          $updateTextFormatFloatingToolbar()\n        })\n      }),\n\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          $updateTextFormatFloatingToolbar()\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      )\n    )\n  }, [editor, $updateTextFormatFloatingToolbar])\n\n  return (\n    <div\n      ref={popupCharStylesEditorRef}\n      className=\"bg-background absolute top-0 left-0 flex gap-1 rounded-md border p-1 opacity-0 shadow-md transition-opacity duration-300 will-change-transform\"\n    >\n      {editor.isEditable() && (\n        <>\n          <ToggleGroup\n            type=\"multiple\"\n            defaultValue={[\n              isBold ? \"bold\" : \"\",\n              isItalic ? \"italic\" : \"\",\n              isUnderline ? \"underline\" : \"\",\n              isStrikethrough ? \"strikethrough\" : \"\",\n              isSubscript ? \"subscript\" : \"\",\n              isSuperscript ? \"superscript\" : \"\",\n              isCode ? \"code\" : \"\",\n              isLink ? \"link\" : \"\",\n            ]}\n          >\n            <ToggleGroupItem\n              value=\"bold\"\n              aria-label=\"Toggle bold\"\n              onClick={() => {\n                editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"bold\")\n              }}\n              size=\"sm\"\n            >\n              <BoldIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n            <ToggleGroupItem\n              value=\"italic\"\n              aria-label=\"Toggle italic\"\n              onClick={() => {\n                editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"italic\")\n              }}\n              size=\"sm\"\n            >\n              <ItalicIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n            <ToggleGroupItem\n              value=\"underline\"\n              aria-label=\"Toggle underline\"\n              onClick={() => {\n                editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"underline\")\n              }}\n              size=\"sm\"\n            >\n              <UnderlineIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n            <ToggleGroupItem\n              value=\"strikethrough\"\n              aria-label=\"Toggle strikethrough\"\n              onClick={() => {\n                editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"strikethrough\")\n              }}\n              size=\"sm\"\n            >\n              <StrikethroughIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n            <Separator orientation=\"vertical\" />\n            <ToggleGroupItem\n              value=\"code\"\n              aria-label=\"Toggle code\"\n              onClick={() => {\n                editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"code\")\n              }}\n              size=\"sm\"\n            >\n              <CodeIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n            <ToggleGroupItem\n              value=\"link\"\n              aria-label=\"Toggle link\"\n              onClick={insertLink}\n              size=\"sm\"\n            >\n              <LinkIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n            <Separator orientation=\"vertical\" />\n          </ToggleGroup>\n          <ToggleGroup\n            type=\"single\"\n            defaultValue={\n              isSubscript ? \"subscript\" : isSuperscript ? \"superscript\" : \"\"\n            }\n          >\n            <ToggleGroupItem\n              value=\"subscript\"\n              aria-label=\"Toggle subscript\"\n              onClick={() => {\n                editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"subscript\")\n              }}\n              size=\"sm\"\n            >\n              <SubscriptIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n            <ToggleGroupItem\n              value=\"superscript\"\n              aria-label=\"Toggle superscript\"\n              onClick={() => {\n                editor.dispatchCommand(FORMAT_TEXT_COMMAND, \"superscript\")\n              }}\n              size=\"sm\"\n            >\n              <SuperscriptIcon className=\"h-4 w-4\" />\n            </ToggleGroupItem>\n          </ToggleGroup>\n        </>\n      )}\n    </div>\n  )\n}\n\nfunction useFloatingTextFormatToolbar(\n  editor: LexicalEditor,\n  anchorElem: HTMLDivElement | null,\n  setIsLinkEditMode: Dispatch<boolean>\n): JSX.Element | null {\n  const [isText, setIsText] = useState(false)\n  const [isLink, setIsLink] = useState(false)\n  const [isBold, setIsBold] = useState(false)\n  const [isItalic, setIsItalic] = useState(false)\n  const [isUnderline, setIsUnderline] = useState(false)\n  const [isStrikethrough, setIsStrikethrough] = useState(false)\n  const [isSubscript, setIsSubscript] = useState(false)\n  const [isSuperscript, setIsSuperscript] = useState(false)\n  const [isCode, setIsCode] = useState(false)\n\n  const updatePopup = useCallback(() => {\n    editor.getEditorState().read(() => {\n      // Should not to pop up the floating toolbar when using IME input\n      if (editor.isComposing()) {\n        return\n      }\n      const selection = $getSelection()\n      const nativeSelection = window.getSelection()\n      const rootElement = editor.getRootElement()\n\n      if (\n        nativeSelection !== null &&\n        (!$isRangeSelection(selection) ||\n          rootElement === null ||\n          !rootElement.contains(nativeSelection.anchorNode))\n      ) {\n        setIsText(false)\n        return\n      }\n\n      if (!$isRangeSelection(selection)) {\n        return\n      }\n\n      const node = getSelectedNode(selection)\n\n      // Update text format\n      setIsBold(selection.hasFormat(\"bold\"))\n      setIsItalic(selection.hasFormat(\"italic\"))\n      setIsUnderline(selection.hasFormat(\"underline\"))\n      setIsStrikethrough(selection.hasFormat(\"strikethrough\"))\n      setIsSubscript(selection.hasFormat(\"subscript\"))\n      setIsSuperscript(selection.hasFormat(\"superscript\"))\n      setIsCode(selection.hasFormat(\"code\"))\n\n      // Update links\n      const parent = node.getParent()\n      if ($isLinkNode(parent) || $isLinkNode(node)) {\n        setIsLink(true)\n      } else {\n        setIsLink(false)\n      }\n\n      if (\n        !$isCodeHighlightNode(selection.anchor.getNode()) &&\n        selection.getTextContent() !== \"\"\n      ) {\n        setIsText($isTextNode(node) || $isParagraphNode(node))\n      } else {\n        setIsText(false)\n      }\n\n      const rawTextContent = selection.getTextContent().replace(/\\n/g, \"\")\n      if (!selection.isCollapsed() && rawTextContent === \"\") {\n        setIsText(false)\n        return\n      }\n    })\n  }, [editor])\n\n  useEffect(() => {\n    document.addEventListener(\"selectionchange\", updatePopup)\n    return () => {\n      document.removeEventListener(\"selectionchange\", updatePopup)\n    }\n  }, [updatePopup])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(() => {\n        updatePopup()\n      }),\n      editor.registerRootListener(() => {\n        if (editor.getRootElement() === null) {\n          setIsText(false)\n        }\n      })\n    )\n  }, [editor, updatePopup])\n\n  if (!isText || !anchorElem) {\n    return null\n  }\n\n  return createPortal(\n    <FloatingTextFormat\n      editor={editor}\n      anchorElem={anchorElem}\n      isLink={isLink}\n      isBold={isBold}\n      isItalic={isItalic}\n      isStrikethrough={isStrikethrough}\n      isSubscript={isSubscript}\n      isSuperscript={isSuperscript}\n      isUnderline={isUnderline}\n      isCode={isCode}\n      setIsLinkEditMode={setIsLinkEditMode}\n    />,\n    anchorElem\n  )\n}\n\nexport function FloatingTextFormatToolbarPlugin({\n  anchorElem,\n  setIsLinkEditMode,\n}: {\n  anchorElem: HTMLDivElement | null\n  setIsLinkEditMode: Dispatch<boolean>\n}): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n\n  return useFloatingTextFormatToolbar(editor, anchorElem, setIsLinkEditMode)\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/floating-text-format-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/utils/get-dom-range-rect.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport function getDOMRangeRect(\n  nativeSelection: Selection,\n  rootElement: HTMLElement\n): DOMRect {\n  const domRange = nativeSelection.getRangeAt(0)\n\n  let rect\n\n  if (nativeSelection.anchorNode === rootElement) {\n    let inner = rootElement\n    while (inner.firstElementChild != null) {\n      inner = inner.firstElementChild as HTMLElement\n    }\n    rect = inner.getBoundingClientRect()\n  } else {\n    rect = domRange.getBoundingClientRect()\n  }\n\n  return rect\n}\n",
      "type": "registry:component",
      "target": "components/editor/utils/get-dom-range-rect.ts"
    },
    {
      "path": "registry/new-york-v4/editor/utils/get-selected-node.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { $isAtNodeEnd } from \"@lexical/selection\"\nimport { ElementNode, RangeSelection, TextNode } from \"lexical\"\n\nexport function getSelectedNode(\n  selection: RangeSelection\n): TextNode | ElementNode {\n  const anchor = selection.anchor\n  const focus = selection.focus\n  const anchorNode = selection.anchor.getNode()\n  const focusNode = selection.focus.getNode()\n  if (anchorNode === focusNode) {\n    return anchorNode\n  }\n  const isBackward = selection.isBackward()\n  if (isBackward) {\n    return $isAtNodeEnd(focus) ? anchorNode : focusNode\n  } else {\n    return $isAtNodeEnd(anchor) ? anchorNode : focusNode\n  }\n}\n",
      "type": "registry:component",
      "target": "components/editor/utils/get-selected-node.ts"
    },
    {
      "path": "registry/new-york-v4/editor/utils/set-floating-elem-position.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst VERTICAL_GAP = 10\nconst HORIZONTAL_OFFSET = 5\n\nexport function setFloatingElemPosition(\n  targetRect: DOMRect | null,\n  floatingElem: HTMLElement,\n  anchorElem: HTMLElement,\n  isLink: boolean = false,\n  verticalGap: number = VERTICAL_GAP,\n  horizontalOffset: number = HORIZONTAL_OFFSET\n): void {\n  const scrollerElem = anchorElem.parentElement\n\n  if (targetRect === null || !scrollerElem) {\n    floatingElem.style.opacity = \"0\"\n    floatingElem.style.transform = \"translate(-10000px, -10000px)\"\n    return\n  }\n\n  const floatingElemRect = floatingElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const editorScrollerRect = scrollerElem.getBoundingClientRect()\n\n  let top = targetRect.top - floatingElemRect.height - verticalGap\n  let left = targetRect.left - horizontalOffset\n\n  if (top < editorScrollerRect.top) {\n    // adjusted height for link element if the element is at top\n    top +=\n      floatingElemRect.height +\n      targetRect.height +\n      verticalGap * (isLink ? 9 : 2)\n  }\n\n  if (left + floatingElemRect.width > editorScrollerRect.right) {\n    left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset\n  }\n\n  top -= anchorElementRect.top\n  left -= anchorElementRect.left\n\n  floatingElem.style.opacity = \"1\"\n  floatingElem.style.transform = `translate(${left}px, ${top}px)`\n}\n",
      "type": "registry:component",
      "target": "components/editor/utils/set-floating-elem-position.ts"
    }
  ]
}