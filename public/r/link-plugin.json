{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "link-plugin",
  "type": "registry:ui",
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/auto-link-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX } from \"react\"\nimport {\n  createLinkMatcherWithRegExp,\n  AutoLinkPlugin as LexicalAutoLinkPlugin,\n} from \"@lexical/react/LexicalAutoLinkPlugin\"\n\nconst URL_REGEX =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)(?<![-.+():%])/\n\nconst EMAIL_REGEX =\n  /(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/\n\nconst MATCHERS = [\n  createLinkMatcherWithRegExp(URL_REGEX, (text) => {\n    return text.startsWith(\"http\") ? text : `https://${text}`\n  }),\n  createLinkMatcherWithRegExp(EMAIL_REGEX, (text) => {\n    return `mailto:${text}`\n  }),\n]\n\nexport function AutoLinkPlugin(): JSX.Element {\n  return <LexicalAutoLinkPlugin matchers={MATCHERS} />\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/auto-link-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/floating-link-editor-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { Dispatch, JSX, useCallback, useEffect, useRef, useState } from \"react\"\nimport {\n  $createLinkNode,\n  $isAutoLinkNode,\n  $isLinkNode,\n  TOGGLE_LINK_COMMAND,\n} from \"@lexical/link\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { $findMatchingParent, mergeRegister } from \"@lexical/utils\"\nimport {\n  $getSelection,\n  $isLineBreakNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  BaseSelection,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_CRITICAL,\n  COMMAND_PRIORITY_HIGH,\n  COMMAND_PRIORITY_LOW,\n  KEY_ESCAPE_COMMAND,\n  LexicalEditor,\n  SELECTION_CHANGE_COMMAND,\n} from \"lexical\"\nimport { Check, Pencil, Trash, X } from \"lucide-react\"\nimport { createPortal } from \"react-dom\"\n\nimport { getSelectedNode } from \"@/registry/new-york-v4/editor/utils/get-selected-node\"\nimport { setFloatingElemPositionForLinkEditor } from \"@/registry/new-york-v4/editor/utils/set-floating-elem-position-for-link-editor\"\nimport { sanitizeUrl } from \"@/registry/new-york-v4/editor/utils/url\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport { Input } from \"@/registry/new-york-v4/ui/input\"\n\nfunction FloatingLinkEditor({\n  editor,\n  isLink,\n  setIsLink,\n  anchorElem,\n  isLinkEditMode,\n  setIsLinkEditMode,\n}: {\n  editor: LexicalEditor\n  isLink: boolean\n  setIsLink: Dispatch<boolean>\n  anchorElem: HTMLElement\n  isLinkEditMode: boolean\n  setIsLinkEditMode: Dispatch<boolean>\n}): JSX.Element {\n  const editorRef = useRef<HTMLDivElement | null>(null)\n  const inputRef = useRef<HTMLInputElement>(null)\n  const [linkUrl, setLinkUrl] = useState(\"\")\n  const [editedLinkUrl, setEditedLinkUrl] = useState(\"https://\")\n  const [lastSelection, setLastSelection] = useState<BaseSelection | null>(null)\n\n  const $updateLinkEditor = useCallback(() => {\n    const selection = $getSelection()\n    if ($isRangeSelection(selection)) {\n      const node = getSelectedNode(selection)\n      const linkParent = $findMatchingParent(node, $isLinkNode)\n\n      if (linkParent) {\n        setLinkUrl(linkParent.getURL())\n      } else if ($isLinkNode(node)) {\n        setLinkUrl(node.getURL())\n      } else {\n        setLinkUrl(\"\")\n      }\n      if (isLinkEditMode) {\n        setEditedLinkUrl(linkUrl)\n      }\n    }\n    const editorElem = editorRef.current\n    const nativeSelection = window.getSelection()\n    const activeElement = document.activeElement\n\n    if (editorElem === null) {\n      return\n    }\n\n    const rootElement = editor.getRootElement()\n\n    if (\n      selection !== null &&\n      nativeSelection !== null &&\n      rootElement !== null &&\n      rootElement.contains(nativeSelection.anchorNode) &&\n      editor.isEditable()\n    ) {\n      const domRect: DOMRect | undefined =\n        nativeSelection.focusNode?.parentElement?.getBoundingClientRect()\n      if (domRect) {\n        domRect.y += 40\n        setFloatingElemPositionForLinkEditor(domRect, editorElem, anchorElem)\n      }\n      setLastSelection(selection)\n    } else if (!activeElement || activeElement.className !== \"link-input\") {\n      if (rootElement !== null) {\n        setFloatingElemPositionForLinkEditor(null, editorElem, anchorElem)\n      }\n      setLastSelection(null)\n      setIsLinkEditMode(false)\n      setLinkUrl(\"\")\n    }\n\n    return true\n  }, [anchorElem, editor, setIsLinkEditMode, isLinkEditMode, linkUrl])\n\n  useEffect(() => {\n    const scrollerElem = anchorElem.parentElement\n\n    const update = () => {\n      editor.getEditorState().read(() => {\n        $updateLinkEditor()\n      })\n    }\n\n    window.addEventListener(\"resize\", update)\n\n    if (scrollerElem) {\n      scrollerElem.addEventListener(\"scroll\", update)\n    }\n\n    return () => {\n      window.removeEventListener(\"resize\", update)\n\n      if (scrollerElem) {\n        scrollerElem.removeEventListener(\"scroll\", update)\n      }\n    }\n  }, [anchorElem.parentElement, editor, $updateLinkEditor])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(() => {\n          $updateLinkEditor()\n        })\n      }),\n\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          $updateLinkEditor()\n          return true\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        KEY_ESCAPE_COMMAND,\n        () => {\n          if (isLink) {\n            setIsLink(false)\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_HIGH\n      )\n    )\n  }, [editor, $updateLinkEditor, setIsLink, isLink])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      $updateLinkEditor()\n    })\n  }, [editor, $updateLinkEditor])\n\n  useEffect(() => {\n    if (isLinkEditMode && inputRef.current) {\n      inputRef.current.focus()\n      setIsLink(true)\n    }\n  }, [isLinkEditMode, isLink])\n\n  const monitorInputInteraction = (\n    event: React.KeyboardEvent<HTMLInputElement>\n  ) => {\n    if (event.key === \"Enter\") {\n      event.preventDefault()\n      handleLinkSubmission()\n    } else if (event.key === \"Escape\") {\n      event.preventDefault()\n      setIsLinkEditMode(false)\n    }\n  }\n\n  const handleLinkSubmission = () => {\n    if (lastSelection !== null) {\n      if (linkUrl !== \"\") {\n        editor.dispatchCommand(TOGGLE_LINK_COMMAND, sanitizeUrl(editedLinkUrl))\n        editor.update(() => {\n          const selection = $getSelection()\n          if ($isRangeSelection(selection)) {\n            const parent = getSelectedNode(selection).getParent()\n            if ($isAutoLinkNode(parent)) {\n              const linkNode = $createLinkNode(parent.getURL(), {\n                rel: parent.__rel,\n                target: parent.__target,\n                title: parent.__title,\n              })\n              parent.replace(linkNode, true)\n            }\n          }\n        })\n      }\n      setEditedLinkUrl(\"https://\")\n      setIsLinkEditMode(false)\n    }\n  }\n  return (\n    <div\n      ref={editorRef}\n      className=\"absolute top-0 left-0 w-full max-w-sm rounded-md opacity-0 shadow-md\"\n    >\n      {!isLink ? null : isLinkEditMode ? (\n        <div className=\"flex items-center space-x-2 rounded-md border p-1 pl-2\">\n          <Input\n            ref={inputRef}\n            value={editedLinkUrl}\n            onChange={(event) => setEditedLinkUrl(event.target.value)}\n            onKeyDown={monitorInputInteraction}\n            className=\"flex-grow\"\n          />\n          <Button\n            size=\"icon\"\n            variant=\"ghost\"\n            onClick={() => {\n              setIsLinkEditMode(false)\n              setIsLink(false)\n            }}\n            className=\"shrink-0\"\n          >\n            <X className=\"h-4 w-4\" />\n          </Button>\n          <Button\n            size=\"icon\"\n            onClick={handleLinkSubmission}\n            className=\"shrink-0\"\n          >\n            <Check className=\"h-4 w-4\" />\n          </Button>\n        </div>\n      ) : (\n        <div className=\"flex items-center justify-between rounded-md border p-1 pl-2\">\n          <a\n            href={sanitizeUrl(linkUrl)}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            className=\"overflow-hidden text-sm text-ellipsis whitespace-nowrap\"\n          >\n            {linkUrl}\n          </a>\n          <div className=\"flex\">\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              onClick={() => {\n                setEditedLinkUrl(linkUrl)\n                setIsLinkEditMode(true)\n              }}\n            >\n              <Pencil className=\"h-4 w-4\" />\n            </Button>\n            <Button\n              size=\"icon\"\n              variant=\"destructive\"\n              onClick={() => {\n                editor.dispatchCommand(TOGGLE_LINK_COMMAND, null)\n              }}\n            >\n              <Trash className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n\nfunction useFloatingLinkEditorToolbar(\n  editor: LexicalEditor,\n  anchorElem: HTMLDivElement | null,\n  isLinkEditMode: boolean,\n  setIsLinkEditMode: Dispatch<boolean>\n): JSX.Element | null {\n  const [activeEditor, setActiveEditor] = useState(editor)\n  const [isLink, setIsLink] = useState(false)\n\n  useEffect(() => {\n    function $updateToolbar() {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection)) {\n        const focusNode = getSelectedNode(selection)\n        const focusLinkNode = $findMatchingParent(focusNode, $isLinkNode)\n        const focusAutoLinkNode = $findMatchingParent(\n          focusNode,\n          $isAutoLinkNode\n        )\n        if (!(focusLinkNode || focusAutoLinkNode)) {\n          setIsLink(false)\n          return\n        }\n        const badNode = selection\n          .getNodes()\n          .filter((node) => !$isLineBreakNode(node))\n          .find((node) => {\n            const linkNode = $findMatchingParent(node, $isLinkNode)\n            const autoLinkNode = $findMatchingParent(node, $isAutoLinkNode)\n            return (\n              (focusLinkNode && !focusLinkNode.is(linkNode)) ||\n              (linkNode && !linkNode.is(focusLinkNode)) ||\n              (focusAutoLinkNode && !focusAutoLinkNode.is(autoLinkNode)) ||\n              (autoLinkNode &&\n                (!autoLinkNode.is(focusAutoLinkNode) ||\n                  autoLinkNode.getIsUnlinked()))\n            )\n          })\n        if (!badNode) {\n          setIsLink(true)\n        } else {\n          setIsLink(false)\n        }\n      } else if ($isNodeSelection(selection)) {\n        const nodes = selection.getNodes()\n        if (nodes.length === 0) {\n          setIsLink(false)\n          return\n        }\n        const node = nodes[0]\n        const parent = node.getParent()\n        if ($isLinkNode(parent) || $isLinkNode(node)) {\n          setIsLink(true)\n        } else {\n          setIsLink(false)\n        }\n      }\n    }\n    return mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(() => {\n          $updateToolbar()\n        })\n      }),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        (_payload, newEditor) => {\n          $updateToolbar()\n          setActiveEditor(newEditor)\n          return false\n        },\n        COMMAND_PRIORITY_CRITICAL\n      ),\n      editor.registerCommand(\n        CLICK_COMMAND,\n        (payload) => {\n          const selection = $getSelection()\n          if ($isRangeSelection(selection)) {\n            const node = getSelectedNode(selection)\n            const linkNode = $findMatchingParent(node, $isLinkNode)\n            if ($isLinkNode(linkNode) && (payload.metaKey || payload.ctrlKey)) {\n              window.open(linkNode.getURL(), \"_blank\")\n              return true\n            }\n          }\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      )\n    )\n  }, [editor])\n\n  if (!anchorElem) {\n    return null\n  }\n\n  return createPortal(\n    <FloatingLinkEditor\n      editor={activeEditor}\n      isLink={isLink}\n      anchorElem={anchorElem}\n      setIsLink={setIsLink}\n      isLinkEditMode={isLinkEditMode}\n      setIsLinkEditMode={setIsLinkEditMode}\n    />,\n    anchorElem\n  )\n}\n\nexport function FloatingLinkEditorPlugin({\n  anchorElem,\n  isLinkEditMode,\n  setIsLinkEditMode,\n}: {\n  anchorElem: HTMLDivElement | null\n  isLinkEditMode: boolean\n  setIsLinkEditMode: Dispatch<boolean>\n}): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n\n  return useFloatingLinkEditorToolbar(\n    editor,\n    anchorElem,\n    isLinkEditMode,\n    setIsLinkEditMode\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/floating-link-editor-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/link-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX } from \"react\"\nimport { LinkPlugin as LexicalLinkPlugin } from \"@lexical/react/LexicalLinkPlugin\"\n\nimport { validateUrl } from \"@/registry/new-york-v4/editor/utils/url\"\n\nexport function LinkPlugin(): JSX.Element {\n  return <LexicalLinkPlugin validateUrl={validateUrl} />\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/link-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/utils/set-floating-elem-position-for-link-editor.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst VERTICAL_GAP = 10\nconst HORIZONTAL_OFFSET = 5\n\nexport function setFloatingElemPositionForLinkEditor(\n  targetRect: DOMRect | null,\n  floatingElem: HTMLElement,\n  anchorElem: HTMLElement,\n  verticalGap: number = VERTICAL_GAP,\n  horizontalOffset: number = HORIZONTAL_OFFSET\n): void {\n  const scrollerElem = anchorElem.parentElement\n\n  if (targetRect === null || !scrollerElem) {\n    floatingElem.style.opacity = \"0\"\n    floatingElem.style.transform = \"translate(-10000px, -10000px)\"\n    return\n  }\n\n  const floatingElemRect = floatingElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const editorScrollerRect = scrollerElem.getBoundingClientRect()\n\n  let top = targetRect.top - verticalGap\n  let left = targetRect.left - horizontalOffset\n\n  if (top < editorScrollerRect.top) {\n    top += floatingElemRect.height + targetRect.height + verticalGap * 2\n  }\n\n  if (left + floatingElemRect.width > editorScrollerRect.right) {\n    left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset\n  }\n\n  top -= anchorElementRect.top\n  left -= anchorElementRect.left\n\n  floatingElem.style.opacity = \"1\"\n  floatingElem.style.transform = `translate(${left}px, ${top}px)`\n}\n",
      "type": "registry:component",
      "target": "components/editor/utils/set-floating-elem-position-for-link-editor.ts"
    },
    {
      "path": "registry/new-york-v4/editor/utils/url.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SUPPORTED_URL_PROTOCOLS = new Set([\n  \"http:\",\n  \"https:\",\n  \"mailto:\",\n  \"sms:\",\n  \"tel:\",\n])\n\nexport function sanitizeUrl(url: string): string {\n  try {\n    const parsedUrl = new URL(url)\n    // eslint-disable-next-line no-script-url\n    if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n      return \"about:blank\"\n    }\n  } catch {\n    return url\n  }\n  return url\n}\n\n// Source: https://stackoverflow.com/a/8234912/2013580\nconst urlRegExp = new RegExp(\n  /((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=+$,\\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[+~%/.\\w-_]*)?\\??(?:[-+=&;%@.\\w_]*)#?(?:[\\w]*))?)/\n)\nexport function validateUrl(url: string): boolean {\n  // TODO Fix UI for link insertion; it should never default to an invalid URL such as https://.\n  // Maybe show a dialog where they user can type the URL before inserting it.\n  return url === \"https://\" || urlRegExp.test(url)\n}\n",
      "type": "registry:component",
      "target": "components/editor/utils/url.ts"
    }
  ]
}