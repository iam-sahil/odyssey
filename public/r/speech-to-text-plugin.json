{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "speech-to-text-plugin",
  "type": "registry:ui",
  "registryDependencies": [
    "button",
    "tooltip",
    "@shadcn-editor/actions-plugin"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/actions/speech-to-text-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { useEffect, useRef, useState } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport type { LexicalCommand, LexicalEditor, RangeSelection } from \"lexical\"\nimport {\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_EDITOR,\n  createCommand,\n  REDO_COMMAND,\n  UNDO_COMMAND,\n} from \"lexical\"\nimport { MicIcon } from \"lucide-react\"\n\nimport { useReport } from \"@/registry/new-york-v4/editor/editor-hooks/use-report\"\nimport { CAN_USE_DOM } from \"@/registry/new-york-v4/editor/shared/can-use-dom\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/registry/new-york-v4/ui/tooltip\"\n\nexport const SPEECH_TO_TEXT_COMMAND: LexicalCommand<boolean> = createCommand(\n  \"SPEECH_TO_TEXT_COMMAND\"\n)\n\nconst VOICE_COMMANDS: Readonly<\n  Record<\n    string,\n    (arg0: { editor: LexicalEditor; selection: RangeSelection }) => void\n  >\n> = {\n  \"\\n\": ({ selection }) => {\n    selection.insertParagraph()\n  },\n  redo: ({ editor }) => {\n    editor.dispatchCommand(REDO_COMMAND, undefined)\n  },\n  undo: ({ editor }) => {\n    editor.dispatchCommand(UNDO_COMMAND, undefined)\n  },\n}\n\nexport const SUPPORT_SPEECH_RECOGNITION: boolean =\n  CAN_USE_DOM &&\n  (\"SpeechRecognition\" in window || \"webkitSpeechRecognition\" in window)\n\nfunction SpeechToTextPluginImpl() {\n  const [editor] = useLexicalComposerContext()\n  const [isEnabled, setIsEnabled] = useState<boolean>(false)\n  const [isSpeechToText, setIsSpeechToText] = useState<boolean>(false)\n  const SpeechRecognition =\n    // @ts-expect-error missing type\n    CAN_USE_DOM && (window.SpeechRecognition || window.webkitSpeechRecognition)\n  const recognition = useRef<typeof SpeechRecognition | null>(null)\n  const report = useReport()\n\n  useEffect(() => {\n    if (isEnabled && recognition.current === null) {\n      recognition.current = new SpeechRecognition()\n      recognition.current.continuous = true\n      recognition.current.interimResults = true\n      recognition.current.addEventListener(\n        \"result\",\n        (event: typeof SpeechRecognition) => {\n          const resultItem = event.results.item(event.resultIndex)\n          const { transcript } = resultItem.item(0)\n          report(transcript)\n\n          if (!resultItem.isFinal) {\n            return\n          }\n\n          editor.update(() => {\n            const selection = $getSelection()\n\n            if ($isRangeSelection(selection)) {\n              const command = VOICE_COMMANDS[transcript.toLowerCase().trim()]\n\n              if (command) {\n                command({\n                  editor,\n                  selection,\n                })\n              } else if (transcript.match(/\\s*\\n\\s*/)) {\n                selection.insertParagraph()\n              } else {\n                selection.insertText(transcript)\n              }\n            }\n          })\n        }\n      )\n    }\n\n    if (recognition.current) {\n      if (isEnabled) {\n        recognition.current.start()\n      } else {\n        recognition.current.stop()\n      }\n    }\n\n    return () => {\n      if (recognition.current !== null) {\n        recognition.current.stop()\n      }\n    }\n  }, [SpeechRecognition, editor, isEnabled, report])\n  useEffect(() => {\n    return editor.registerCommand(\n      SPEECH_TO_TEXT_COMMAND,\n      (_isEnabled: boolean) => {\n        setIsEnabled(_isEnabled)\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR\n    )\n  }, [editor])\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>\n        <Button\n          onClick={() => {\n            editor.dispatchCommand(SPEECH_TO_TEXT_COMMAND, !isSpeechToText)\n            setIsSpeechToText(!isSpeechToText)\n          }}\n          variant={isSpeechToText ? \"secondary\" : \"ghost\"}\n          title=\"Speech To Text\"\n          aria-label={`${isSpeechToText ? \"Enable\" : \"Disable\"} speech to text`}\n          className=\"p-2\"\n          size={\"sm\"}\n        >\n          <MicIcon className=\"size-4\" />\n        </Button>\n      </TooltipTrigger>\n      <TooltipContent>Speech To Text</TooltipContent>\n    </Tooltip>\n  )\n}\n\nexport const SpeechToTextPlugin = SUPPORT_SPEECH_RECOGNITION\n  ? SpeechToTextPluginImpl\n  : () => null\n",
      "type": "registry:component",
      "target": "components/editor/plugins/actions/speech-to-text-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-report.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { useCallback, useEffect, useRef } from \"react\"\n\nconst getElement = (): HTMLElement => {\n  let element = document.getElementById(\"report-container\")\n\n  if (element === null) {\n    element = document.createElement(\"div\")\n    element.id = \"report-container\"\n    element.style.position = \"fixed\"\n    element.style.top = \"50%\"\n    element.style.left = \"50%\"\n    element.style.fontSize = \"32px\"\n    element.style.transform = \"translate(-50%, -50px)\"\n    element.style.padding = \"20px\"\n    element.style.background = \"rgba(240, 240, 240, 0.4)\"\n    element.style.borderRadius = \"20px\"\n\n    if (document.body) {\n      document.body.appendChild(element)\n    }\n  }\n\n  return element\n}\n\nexport function useReport(): (arg0: string) => ReturnType<typeof setTimeout> {\n  const timer = useRef<ReturnType<typeof setTimeout> | null>(null)\n  const cleanup = useCallback(() => {\n    if (timer.current !== null) {\n      clearTimeout(timer.current)\n      timer.current = null\n    }\n\n    if (document.body) {\n      document.body.removeChild(getElement())\n    }\n  }, [])\n\n  useEffect(() => {\n    return cleanup\n  }, [cleanup])\n\n  return useCallback(\n    (content) => {\n      console.log(content)\n      const element = getElement()\n      if (timer.current !== null) {\n        clearTimeout(timer.current)\n      }\n      element.innerHTML = content\n      timer.current = setTimeout(cleanup, 1000)\n      return timer.current\n    },\n    [cleanup]\n  )\n}\n",
      "type": "registry:hook",
      "target": "components/editor/editor-hooks/use-report.ts"
    },
    {
      "path": "registry/new-york-v4/editor/shared/can-use-dom.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport const CAN_USE_DOM: boolean =\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\"\n",
      "type": "registry:component",
      "target": "components/editor/shared/can-use-dom.ts"
    }
  ]
}