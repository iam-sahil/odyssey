{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auto-embed-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/utils",
    "@lexical/markdown"
  ],
  "registryDependencies": [
    "button",
    "command",
    "dialog",
    "input",
    "popover",
    "select",
    "@shadcn-editor/toolbar-plugin"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/embeds/auto-embed-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useMemo, useState } from \"react\"\nimport {\n  AutoEmbedOption,\n  EmbedConfig,\n  EmbedMatchResult,\n  LexicalAutoEmbedPlugin,\n  URL_MATCHER,\n} from \"@lexical/react/LexicalAutoEmbedPlugin\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { PopoverPortal } from \"@radix-ui/react-popover\"\nimport type { LexicalEditor } from \"lexical\"\nimport { TwitterIcon, YoutubeIcon } from \"lucide-react\"\n\nimport { useEditorModal } from \"@/registry/new-york-v4/editor/editor-hooks/use-modal\"\nimport { INSERT_TWEET_COMMAND } from \"@/registry/new-york-v4/editor/plugins/embeds/twitter-plugin\"\nimport { INSERT_YOUTUBE_COMMAND } from \"@/registry/new-york-v4/editor/plugins/embeds/youtube-plugin\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport {\n  Command,\n  CommandGroup,\n  CommandItem,\n  CommandList,\n} from \"@/registry/new-york-v4/ui/command\"\nimport { DialogFooter } from \"@/registry/new-york-v4/ui/dialog\"\nimport { Input } from \"@/registry/new-york-v4/ui/input\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/new-york-v4/ui/popover\"\n\nexport interface CustomEmbedConfig extends EmbedConfig {\n  // Human readable name of the embeded content e.g. Tweet or Google Map.\n  contentName: string\n\n  // Icon for display.\n  icon?: JSX.Element\n\n  // An example of a matching url https://twitter.com/jack/status/20\n  exampleUrl: string\n\n  // For extra searching.\n  keywords: Array<string>\n\n  // Embed a Project.\n  description?: string\n}\n\nexport const YoutubeEmbedConfig: CustomEmbedConfig = {\n  contentName: \"Youtube Video\",\n\n  exampleUrl: \"https://www.youtube.com/watch?v=jNQXAC9IVRw\",\n\n  // Icon for display.\n  icon: <YoutubeIcon className=\"size-4\" />,\n\n  insertNode: (editor: LexicalEditor, result: EmbedMatchResult) => {\n    editor.dispatchCommand(INSERT_YOUTUBE_COMMAND, result.id)\n  },\n\n  keywords: [\"youtube\", \"video\"],\n\n  // Determine if a given URL is a match and return url data.\n  parseUrl: async (url: string) => {\n    const match =\n      /^.*(youtu\\.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/.exec(url)\n\n    const id = match ? (match?.[2].length === 11 ? match[2] : null) : null\n\n    if (id != null) {\n      return {\n        id,\n        url,\n      }\n    }\n\n    return null\n  },\n\n  type: \"youtube-video\",\n}\n\nexport const TwitterEmbedConfig: CustomEmbedConfig = {\n  // e.g. Tweet or Google Map.\n  contentName: \"Tweet\",\n\n  exampleUrl: \"https://twitter.com/jack/status/20\",\n\n  // Icon for display.\n  icon: <TwitterIcon className=\"size-4\" />,\n\n  // Create the Lexical embed node from the url data.\n  insertNode: (editor: LexicalEditor, result: EmbedMatchResult) => {\n    editor.dispatchCommand(INSERT_TWEET_COMMAND, result.id)\n  },\n\n  // For extra searching.\n  keywords: [\"tweet\", \"twitter\"],\n\n  // Determine if a given URL is a match and return url data.\n  parseUrl: (text: string) => {\n    const match =\n      /^https:\\/\\/(twitter|x)\\.com\\/(#!\\/)?(\\w+)\\/status(es)*\\/(\\d+)/.exec(text)\n\n    if (match != null) {\n      return {\n        id: match[5],\n        url: match[1],\n      }\n    }\n\n    return null\n  },\n\n  type: \"tweet\",\n}\n\nexport const EmbedConfigs = [TwitterEmbedConfig, YoutubeEmbedConfig]\n\nconst debounce = (callback: (text: string) => void, delay: number) => {\n  let timeoutId: number\n  return (text: string) => {\n    window.clearTimeout(timeoutId)\n    timeoutId = window.setTimeout(() => {\n      callback(text)\n    }, delay)\n  }\n}\n\nexport function AutoEmbedDialog({\n  embedConfig,\n  onClose,\n}: {\n  embedConfig: CustomEmbedConfig\n  onClose: () => void\n}): JSX.Element {\n  const [text, setText] = useState(\"\")\n  const [editor] = useLexicalComposerContext()\n  const [embedResult, setEmbedResult] = useState<EmbedMatchResult | null>(null)\n\n  const validateText = useMemo(\n    () =>\n      debounce((inputText: string) => {\n        const urlMatch = URL_MATCHER.exec(inputText)\n        if (embedConfig != null && inputText != null && urlMatch != null) {\n          Promise.resolve(embedConfig.parseUrl(inputText)).then(\n            (parseResult) => {\n              setEmbedResult(parseResult)\n            }\n          )\n        } else if (embedResult != null) {\n          setEmbedResult(null)\n        }\n      }, 200),\n    [embedConfig, embedResult]\n  )\n\n  const onClick = () => {\n    if (embedResult != null) {\n      embedConfig.insertNode(editor, embedResult)\n      onClose()\n    }\n  }\n\n  return (\n    <div className=\"\">\n      <div className=\"space-y-4\">\n        <Input\n          type=\"text\"\n          placeholder={embedConfig.exampleUrl}\n          value={text}\n          data-test-id={`${embedConfig.type}-embed-modal-url`}\n          onChange={(e) => {\n            const { value } = e.target\n            setText(value)\n            validateText(value)\n          }}\n        />\n        <DialogFooter>\n          <Button\n            disabled={!embedResult}\n            onClick={onClick}\n            data-test-id={`${embedConfig.type}-embed-modal-submit-btn`}\n          >\n            Embed\n          </Button>\n        </DialogFooter>\n      </div>\n    </div>\n  )\n}\n\nexport function AutoEmbedPlugin(): JSX.Element {\n  const [modal, showModal] = useEditorModal()\n\n  const openEmbedModal = (embedConfig: CustomEmbedConfig) => {\n    showModal(`Embed ${embedConfig.contentName}`, (onClose) => (\n      <AutoEmbedDialog embedConfig={embedConfig} onClose={onClose} />\n    ))\n  }\n\n  const getMenuOptions = (\n    activeEmbedConfig: CustomEmbedConfig,\n    embedFn: () => void,\n    dismissFn: () => void\n  ) => {\n    return [\n      new AutoEmbedOption(\"Dismiss\", {\n        onSelect: dismissFn,\n      }),\n      new AutoEmbedOption(`Embed ${activeEmbedConfig.contentName}`, {\n        onSelect: embedFn,\n      }),\n    ]\n  }\n\n  return (\n    <>\n      {modal}\n      <LexicalAutoEmbedPlugin<CustomEmbedConfig>\n        embedConfigs={EmbedConfigs}\n        onOpenEmbedModalForConfig={openEmbedModal}\n        getMenuOptions={getMenuOptions}\n        menuRenderFn={(\n          anchorElementRef,\n          {\n            selectedIndex,\n            options,\n            selectOptionAndCleanUp,\n            setHighlightedIndex,\n          }\n        ) => {\n          return anchorElementRef.current ? (\n            <Popover open={true}>\n              <PopoverPortal container={anchorElementRef.current}>\n                <div className=\"-translate-y-full transform\">\n                  <PopoverTrigger />\n                  <PopoverContent\n                    className=\"w-[200px] p-0\"\n                    align=\"start\"\n                    side=\"right\"\n                  >\n                    <Command>\n                      <CommandList>\n                        <CommandGroup>\n                          {options.map((option, i: number) => (\n                            <CommandItem\n                              key={option.key}\n                              value={option.title}\n                              onSelect={() => {\n                                selectOptionAndCleanUp(option)\n                              }}\n                              className=\"flex items-center gap-2\"\n                            >\n                              {option.title}\n                            </CommandItem>\n                          ))}\n                        </CommandGroup>\n                      </CommandList>\n                    </Command>\n                  </PopoverContent>\n                </div>\n              </PopoverPortal>\n            </Popover>\n          ) : null\n        }}\n      />\n    </>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/embeds/auto-embed-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/embeds/twitter-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useEffect } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { $insertNodeToNearestRoot } from \"@lexical/utils\"\nimport { COMMAND_PRIORITY_EDITOR, createCommand, LexicalCommand } from \"lexical\"\n\nimport {\n  $createTweetNode,\n  TweetNode,\n} from \"@/registry/new-york-v4/editor/nodes/embeds/tweet-node\"\n\nexport const INSERT_TWEET_COMMAND: LexicalCommand<string> = createCommand(\n  \"INSERT_TWEET_COMMAND\"\n)\n\nexport function TwitterPlugin(): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (!editor.hasNodes([TweetNode])) {\n      throw new Error(\"TwitterPlugin: TweetNode not registered on editor\")\n    }\n\n    return editor.registerCommand<string>(\n      INSERT_TWEET_COMMAND,\n      (payload) => {\n        const tweetNode = $createTweetNode(payload)\n        $insertNodeToNearestRoot(tweetNode)\n\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR\n    )\n  }, [editor])\n\n  return null\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/embeds/twitter-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/embeds/tweet-node.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, useCallback, useEffect, useRef, useState } from \"react\"\nimport { BlockWithAlignableContents } from \"@lexical/react/LexicalBlockWithAlignableContents\"\nimport {\n  DecoratorBlockNode,\n  SerializedDecoratorBlockNode,\n} from \"@lexical/react/LexicalDecoratorBlockNode\"\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from \"lexical\"\n\nconst WIDGET_SCRIPT_URL = \"https://platform.twitter.com/widgets.js\"\n\ntype TweetComponentProps = Readonly<{\n  className: Readonly<{\n    base: string\n    focus: string\n  }>\n  format: ElementFormatType | null\n  loadingComponent?: JSX.Element | string\n  nodeKey: NodeKey\n  onError?: (error: string) => void\n  onLoad?: () => void\n  tweetID: string\n}>\n\nfunction $convertTweetElement(\n  domNode: HTMLDivElement\n): DOMConversionOutput | null {\n  const id = domNode.getAttribute(\"data-lexical-tweet-id\")\n  if (id) {\n    const node = $createTweetNode(id)\n    return { node }\n  }\n  return null\n}\n\nlet isTwitterScriptLoading = true\n\nfunction TweetComponent({\n  className,\n  format,\n  loadingComponent,\n  nodeKey,\n  onError,\n  onLoad,\n  tweetID,\n}: TweetComponentProps) {\n  const containerRef = useRef<HTMLDivElement | null>(null)\n\n  const previousTweetIDRef = useRef<string>(\"\")\n  const [isTweetLoading, setIsTweetLoading] = useState(false)\n\n  const createTweet = useCallback(async () => {\n    try {\n      // @ts-expect-error Twitter is attached to the window.\n      await window.twttr.widgets.createTweet(tweetID, containerRef.current)\n\n      setIsTweetLoading(false)\n      isTwitterScriptLoading = false\n\n      if (onLoad) {\n        onLoad()\n      }\n    } catch (error) {\n      if (onError) {\n        onError(String(error))\n      }\n    }\n  }, [onError, onLoad, tweetID])\n\n  useEffect(() => {\n    if (tweetID !== previousTweetIDRef.current) {\n      setIsTweetLoading(true)\n\n      if (isTwitterScriptLoading) {\n        const script = document.createElement(\"script\")\n        script.src = WIDGET_SCRIPT_URL\n        script.async = true\n        document.body?.appendChild(script)\n        script.onload = createTweet\n        if (onError) {\n          script.onerror = onError as OnErrorEventHandler\n        }\n      } else {\n        createTweet()\n      }\n\n      if (previousTweetIDRef) {\n        previousTweetIDRef.current = tweetID\n      }\n    }\n  }, [createTweet, onError, tweetID])\n\n  return (\n    <BlockWithAlignableContents\n      className={className}\n      format={format}\n      nodeKey={nodeKey}\n    >\n      {isTweetLoading ? loadingComponent : null}\n      <div\n        style={{ display: \"inline-block\", width: \"550px\" }}\n        ref={containerRef}\n      />\n    </BlockWithAlignableContents>\n  )\n}\n\nexport type SerializedTweetNode = Spread<\n  {\n    id: string\n  },\n  SerializedDecoratorBlockNode\n>\n\nexport class TweetNode extends DecoratorBlockNode {\n  __id: string\n\n  static getType(): string {\n    return \"tweet\"\n  }\n\n  static clone(node: TweetNode): TweetNode {\n    return new TweetNode(node.__id, node.__format, node.__key)\n  }\n\n  static importJSON(serializedNode: SerializedTweetNode): TweetNode {\n    const node = $createTweetNode(serializedNode.id)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  exportJSON(): SerializedTweetNode {\n    return {\n      ...super.exportJSON(),\n      id: this.getId(),\n      type: \"tweet\",\n      version: 1,\n    }\n  }\n\n  static importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {\n      div: (domNode: HTMLDivElement) => {\n        if (!domNode.hasAttribute(\"data-lexical-tweet-id\")) {\n          return null\n        }\n        return {\n          conversion: $convertTweetElement,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement(\"div\")\n    element.setAttribute(\"data-lexical-tweet-id\", this.__id)\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  constructor(id: string, format?: ElementFormatType, key?: NodeKey) {\n    super(format, key)\n    this.__id = id\n  }\n\n  getId(): string {\n    return this.__id\n  }\n\n  getTextContent(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _includeInert?: boolean | undefined,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _includeDirectionless?: false | undefined\n  ): string {\n    return `https://x.com/i/web/status/${this.__id}`\n  }\n\n  decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    const embedBlockTheme = config.theme.embedBlock || {}\n    const className = {\n      base: embedBlockTheme.base || \"\",\n      focus: embedBlockTheme.focus || \"\",\n    }\n    return (\n      <TweetComponent\n        className={className}\n        format={this.__format}\n        loadingComponent=\"Loading...\"\n        nodeKey={this.getKey()}\n        tweetID={this.__id}\n      />\n    )\n  }\n}\n\nexport function $createTweetNode(tweetID: string): TweetNode {\n  return new TweetNode(tweetID)\n}\n\nexport function $isTweetNode(\n  node: TweetNode | LexicalNode | null | undefined\n): node is TweetNode {\n  return node instanceof TweetNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/embeds/tweet-node.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/embeds/youtube-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useEffect } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { $insertNodeToNearestRoot } from \"@lexical/utils\"\nimport { COMMAND_PRIORITY_EDITOR, createCommand, LexicalCommand } from \"lexical\"\n\nimport {\n  $createYouTubeNode,\n  YouTubeNode,\n} from \"@/registry/new-york-v4/editor/nodes/embeds/youtube-node\"\n\nexport const INSERT_YOUTUBE_COMMAND: LexicalCommand<string> = createCommand(\n  \"INSERT_YOUTUBE_COMMAND\"\n)\n\nexport function YouTubePlugin(): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (!editor.hasNodes([YouTubeNode])) {\n      throw new Error(\"YouTubePlugin: YouTubeNode not registered on editor\")\n    }\n\n    return editor.registerCommand<string>(\n      INSERT_YOUTUBE_COMMAND,\n      (payload) => {\n        const youTubeNode = $createYouTubeNode(payload)\n        $insertNodeToNearestRoot(youTubeNode)\n\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR\n    )\n  }, [editor])\n\n  return null\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/embeds/youtube-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/embeds/youtube-node.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX } from \"react\"\nimport { BlockWithAlignableContents } from \"@lexical/react/LexicalBlockWithAlignableContents\"\nimport {\n  DecoratorBlockNode,\n  SerializedDecoratorBlockNode,\n} from \"@lexical/react/LexicalDecoratorBlockNode\"\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from \"lexical\"\n\ntype YouTubeComponentProps = Readonly<{\n  className: Readonly<{\n    base: string\n    focus: string\n  }>\n  format: ElementFormatType | null\n  nodeKey: NodeKey\n  videoID: string\n}>\n\nfunction YouTubeComponent({\n  className,\n  format,\n  nodeKey,\n  videoID,\n}: YouTubeComponentProps) {\n  return (\n    <BlockWithAlignableContents\n      className={className}\n      format={format}\n      nodeKey={nodeKey}\n    >\n      <iframe\n        width=\"560\"\n        height=\"315\"\n        src={`https://www.youtube-nocookie.com/embed/${videoID}`}\n        frameBorder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowFullScreen={true}\n        title=\"YouTube video\"\n      />\n    </BlockWithAlignableContents>\n  )\n}\n\nexport type SerializedYouTubeNode = Spread<\n  {\n    videoID: string\n  },\n  SerializedDecoratorBlockNode\n>\n\nfunction $convertYoutubeElement(\n  domNode: HTMLElement\n): null | DOMConversionOutput {\n  const videoID = domNode.getAttribute(\"data-lexical-youtube\")\n  if (videoID) {\n    const node = $createYouTubeNode(videoID)\n    return { node }\n  }\n  return null\n}\n\nexport class YouTubeNode extends DecoratorBlockNode {\n  __id: string\n\n  static getType(): string {\n    return \"youtube\"\n  }\n\n  static clone(node: YouTubeNode): YouTubeNode {\n    return new YouTubeNode(node.__id, node.__format, node.__key)\n  }\n\n  static importJSON(serializedNode: SerializedYouTubeNode): YouTubeNode {\n    const node = $createYouTubeNode(serializedNode.videoID)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  exportJSON(): SerializedYouTubeNode {\n    return {\n      ...super.exportJSON(),\n      type: \"youtube\",\n      version: 1,\n      videoID: this.__id,\n    }\n  }\n\n  constructor(id: string, format?: ElementFormatType, key?: NodeKey) {\n    super(format, key)\n    this.__id = id\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement(\"iframe\")\n    element.setAttribute(\"data-lexical-youtube\", this.__id)\n    element.setAttribute(\"width\", \"560\")\n    element.setAttribute(\"height\", \"315\")\n    element.setAttribute(\n      \"src\",\n      `https://www.youtube-nocookie.com/embed/${this.__id}`\n    )\n    element.setAttribute(\"frameborder\", \"0\")\n    element.setAttribute(\n      \"allow\",\n      \"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n    )\n    element.setAttribute(\"allowfullscreen\", \"true\")\n    element.setAttribute(\"title\", \"YouTube video\")\n    return { element }\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      iframe: (domNode: HTMLElement) => {\n        if (!domNode.hasAttribute(\"data-lexical-youtube\")) {\n          return null\n        }\n        return {\n          conversion: $convertYoutubeElement,\n          priority: 1,\n        }\n      },\n    }\n  }\n\n  updateDOM(): false {\n    return false\n  }\n\n  getId(): string {\n    return this.__id\n  }\n\n  getTextContent(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _includeInert?: boolean | undefined,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _includeDirectionless?: false | undefined\n  ): string {\n    return `https://www.youtube.com/watch?v=${this.__id}`\n  }\n\n  decorate(_editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    const embedBlockTheme = config.theme.embedBlock || {}\n    const className = {\n      base: embedBlockTheme.base || \"\",\n      focus: embedBlockTheme.focus || \"\",\n    }\n    return (\n      <YouTubeComponent\n        className={className}\n        format={this.__format}\n        nodeKey={this.getKey()}\n        videoID={this.__id}\n      />\n    )\n  }\n}\n\nexport function $createYouTubeNode(videoID: string): YouTubeNode {\n  return new YouTubeNode(videoID)\n}\n\nexport function $isYouTubeNode(\n  node: YouTubeNode | LexicalNode | null | undefined\n): node is YouTubeNode {\n  return node instanceof YouTubeNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/embeds/youtube-node.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-modal.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useCallback, useMemo, useState } from \"react\"\nimport * as React from \"react\"\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york-v4/ui/dialog\"\n\nexport function useEditorModal(): [\n  JSX.Element | null,\n  (title: string, showModal: (onClose: () => void) => JSX.Element) => void,\n] {\n  const [modalContent, setModalContent] = useState<null | {\n    closeOnClickOutside: boolean\n    content: JSX.Element\n    title: string\n  }>(null)\n\n  const onClose = useCallback(() => {\n    setModalContent(null)\n  }, [])\n\n  const modal = useMemo(() => {\n    if (modalContent === null) {\n      return null\n    }\n    const { title, content } = modalContent\n    return (\n      <Dialog open={true} onOpenChange={onClose}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>{title}</DialogTitle>\n          </DialogHeader>\n          {content}\n        </DialogContent>\n      </Dialog>\n    )\n  }, [modalContent, onClose])\n\n  const showModal = useCallback(\n    (\n      title: string,\n      getContent: (onClose: () => void) => JSX.Element,\n      closeOnClickOutside = false\n    ) => {\n      setModalContent({\n        closeOnClickOutside,\n        content: getContent(onClose),\n        title,\n      })\n    },\n    [onClose]\n  )\n\n  return [modal, showModal]\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-hooks/use-modal.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/transformers/markdown-tweet-transformer.ts",
      "content": "import { ElementTransformer } from \"@lexical/markdown\"\n\nimport {\n  $createTweetNode,\n  $isTweetNode,\n  TweetNode,\n} from \"@/registry/new-york-v4/editor/nodes/embeds/tweet-node\"\n\nexport const TWEET: ElementTransformer = {\n  dependencies: [TweetNode],\n  export: (node) => {\n    if (!$isTweetNode(node)) {\n      return null\n    }\n\n    return `<tweet id=\"${node.getId()}\" />`\n  },\n  regExp: /<tweet id=\"([^\"]+?)\"\\s?\\/>\\s?$/,\n  replace: (textNode, _1, match) => {\n    const [, id] = match\n    const tweetNode = $createTweetNode(id)\n    textNode.replace(tweetNode)\n  },\n  type: \"element\",\n}\n",
      "type": "registry:component",
      "target": "components/editor/transformers/markdown-tweet-transformer.ts"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert/insert-embeds.tsx",
      "content": "\"use client\"\n\nimport { INSERT_EMBED_COMMAND } from \"@lexical/react/LexicalAutoEmbedPlugin\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { EmbedConfigs } from \"@/registry/new-york-v4/editor/plugins/embeds/auto-embed-plugin\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function InsertEmbeds() {\n  const { activeEditor } = useToolbarContext()\n  return EmbedConfigs.map((embedConfig) => (\n    <SelectItem\n      key={embedConfig.type}\n      value={embedConfig.type}\n      onPointerUp={() => {\n        activeEditor.dispatchCommand(INSERT_EMBED_COMMAND, embedConfig.type)\n      }}\n      className=\"\"\n    >\n      <div className=\"flex items-center gap-1\">\n        {embedConfig.icon}\n        <span>{embedConfig.contentName}</span>\n      </div>\n    </SelectItem>\n  ))\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-embeds.tsx"
    }
  ]
}