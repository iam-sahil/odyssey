{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "table-plugin",
  "type": "registry:ui",
  "dependencies": [
    "lodash",
    "react-colorful",
    "@lexical/table",
    "@lexical/utils",
    "@lexical/markdown"
  ],
  "devDependencies": [
    "@types/lodash"
  ],
  "registryDependencies": [
    "button",
    "command",
    "dialog",
    "input",
    "label",
    "popover",
    "select",
    "@shadcn-editor/toolbar-plugin"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/table-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport {\n  createContext,\n  JSX,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\"\nimport * as React from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport {\n  $createTableNodeWithDimensions,\n  INSERT_TABLE_COMMAND,\n  TableNode,\n} from \"@lexical/table\"\nimport {\n  $insertNodes,\n  COMMAND_PRIORITY_EDITOR,\n  createCommand,\n  EditorThemeClasses,\n  Klass,\n  LexicalCommand,\n  LexicalEditor,\n  LexicalNode,\n} from \"lexical\"\n\nimport { invariant } from \"@/registry/new-york-v4/editor/shared/invariant\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport { DialogFooter } from \"@/registry/new-york-v4/ui/dialog\"\nimport { Input } from \"@/registry/new-york-v4/ui/input\"\nimport { Label } from \"@/registry/new-york-v4/ui/label\"\n\nexport type InsertTableCommandPayload = Readonly<{\n  columns: string\n  rows: string\n  includeHeaders?: boolean\n}>\n\nexport type CellContextShape = {\n  cellEditorConfig: null | CellEditorConfig\n  cellEditorPlugins: null | JSX.Element | Array<JSX.Element>\n  set: (\n    cellEditorConfig: null | CellEditorConfig,\n    cellEditorPlugins: null | JSX.Element | Array<JSX.Element>\n  ) => void\n}\n\nexport type CellEditorConfig = Readonly<{\n  namespace: string\n  nodes?: ReadonlyArray<Klass<LexicalNode>>\n  onError: (error: Error, editor: LexicalEditor) => void\n  readOnly?: boolean\n  theme?: EditorThemeClasses\n}>\n\nexport const INSERT_NEW_TABLE_COMMAND: LexicalCommand<InsertTableCommandPayload> =\n  createCommand(\"INSERT_NEW_TABLE_COMMAND\")\n\nexport const CellContext = createContext<CellContextShape>({\n  cellEditorConfig: null,\n  cellEditorPlugins: null,\n  set: () => {\n    // Empty\n  },\n})\n\nexport function TableContext({ children }: { children: JSX.Element }) {\n  const [contextValue, setContextValue] = useState<{\n    cellEditorConfig: null | CellEditorConfig\n    cellEditorPlugins: null | JSX.Element | Array<JSX.Element>\n  }>({\n    cellEditorConfig: null,\n    cellEditorPlugins: null,\n  })\n  return (\n    <CellContext.Provider\n      value={useMemo(\n        () => ({\n          cellEditorConfig: contextValue.cellEditorConfig,\n          cellEditorPlugins: contextValue.cellEditorPlugins,\n          set: (cellEditorConfig, cellEditorPlugins) => {\n            setContextValue({ cellEditorConfig, cellEditorPlugins })\n          },\n        }),\n        [contextValue.cellEditorConfig, contextValue.cellEditorPlugins]\n      )}\n    >\n      {children}\n    </CellContext.Provider>\n  )\n}\n\nexport function InsertTableDialog({\n  activeEditor,\n  onClose,\n}: {\n  activeEditor: LexicalEditor\n  onClose: () => void\n}): JSX.Element {\n  const [rows, setRows] = useState(\"5\")\n  const [columns, setColumns] = useState(\"5\")\n  const [isDisabled, setIsDisabled] = useState(true)\n\n  useEffect(() => {\n    const row = Number(rows)\n    const column = Number(columns)\n    if (row && row > 0 && row <= 500 && column && column > 0 && column <= 50) {\n      setIsDisabled(false)\n    } else {\n      setIsDisabled(true)\n    }\n  }, [rows, columns])\n\n  const onClick = () => {\n    activeEditor.dispatchCommand(INSERT_TABLE_COMMAND, {\n      columns,\n      rows,\n    })\n\n    onClose()\n  }\n\n  return (\n    <>\n      <div className=\"grid gap-4\">\n        <div className=\"grid gap-2\">\n          <Label htmlFor=\"rows\">Number of rows</Label>\n          <Input\n            id=\"rows\"\n            placeholder={\"# of rows (1-500)\"}\n            onChange={(e) => setRows(e.target.value)}\n            value={rows}\n            data-test-id=\"table-modal-rows\"\n            type=\"number\"\n          />\n        </div>\n        <div className=\"grid gap-2\">\n          <Label htmlFor=\"columns\">Number of columns</Label>\n          <Input\n            id=\"columns\"\n            placeholder={\"# of columns (1-50)\"}\n            onChange={(e) => setColumns(e.target.value)}\n            value={columns}\n            data-test-id=\"table-modal-columns\"\n            type=\"number\"\n          />\n        </div>\n      </div>\n      <DialogFooter data-test-id=\"table-model-confirm-insert\">\n        <Button disabled={isDisabled} onClick={onClick}>\n          Confirm\n        </Button>\n      </DialogFooter>\n    </>\n  )\n}\n\nexport function TablePlugin({\n  cellEditorConfig,\n  children,\n}: {\n  cellEditorConfig: CellEditorConfig\n  children: JSX.Element | Array<JSX.Element>\n}): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n  const cellContext = useContext(CellContext)\n\n  useEffect(() => {\n    if (!editor.hasNodes([TableNode])) {\n      invariant(false, \"TablePlugin: TableNode is not registered on editor\")\n    }\n\n    cellContext.set(cellEditorConfig, children)\n\n    return editor.registerCommand<InsertTableCommandPayload>(\n      INSERT_NEW_TABLE_COMMAND,\n      ({ columns, rows, includeHeaders }) => {\n        const tableNode = $createTableNodeWithDimensions(\n          Number(rows),\n          Number(columns),\n          includeHeaders\n        )\n        $insertNodes([tableNode])\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR\n    )\n  }, [cellContext, cellEditorConfig, children, editor])\n\n  return null\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/table-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert-plugin.tsx",
      "content": "\"use client\"\n\nimport { PlusIcon } from \"lucide-react\"\n\nimport { useEditorModal } from \"@/registry/new-york-v4/editor/editor-hooks/use-modal\"\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectTrigger,\n} from \"@/registry/new-york-v4/ui/select\"\n\nexport function BlockInsertPlugin({ children }: { children: React.ReactNode }) {\n  const [modal] = useEditorModal()\n\n  return (\n    <>\n      {modal}\n      <Select value={\"\"}>\n        <SelectTrigger className=\"!h-8 w-min gap-1\">\n          <PlusIcon className=\"size-4\" />\n          <span>Insert</span>\n        </SelectTrigger>\n        <SelectContent>\n          <SelectGroup>{children}</SelectGroup>\n        </SelectContent>\n      </Select>\n    </>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert/insert-table.tsx",
      "content": "\"use client\"\n\nimport { TableIcon } from \"lucide-react\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { InsertTableDialog } from \"@/registry/new-york-v4/editor/plugins/table-plugin\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function InsertTable() {\n  const { activeEditor, showModal } = useToolbarContext()\n\n  return (\n    <SelectItem\n      value=\"table\"\n      onPointerUp={() =>\n        showModal(\"Insert Table\", (onClose) => (\n          <InsertTableDialog activeEditor={activeEditor} onClose={onClose} />\n        ))\n      }\n      className=\"\"\n    >\n      <div className=\"flex items-center gap-1\">\n        <TableIcon className=\"size-4\" />\n        <span>Table</span>\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-table.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-modal.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useCallback, useMemo, useState } from \"react\"\nimport * as React from \"react\"\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york-v4/ui/dialog\"\n\nexport function useEditorModal(): [\n  JSX.Element | null,\n  (title: string, showModal: (onClose: () => void) => JSX.Element) => void,\n] {\n  const [modalContent, setModalContent] = useState<null | {\n    closeOnClickOutside: boolean\n    content: JSX.Element\n    title: string\n  }>(null)\n\n  const onClose = useCallback(() => {\n    setModalContent(null)\n  }, [])\n\n  const modal = useMemo(() => {\n    if (modalContent === null) {\n      return null\n    }\n    const { title, content } = modalContent\n    return (\n      <Dialog open={true} onOpenChange={onClose}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>{title}</DialogTitle>\n          </DialogHeader>\n          {content}\n        </DialogContent>\n      </Dialog>\n    )\n  }, [modalContent, onClose])\n\n  const showModal = useCallback(\n    (\n      title: string,\n      getContent: (onClose: () => void) => JSX.Element,\n      closeOnClickOutside = false\n    ) => {\n      setModalContent({\n        closeOnClickOutside,\n        content: getContent(onClose),\n        title,\n      })\n    },\n    [onClose]\n  )\n\n  return [modal, showModal]\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-hooks/use-modal.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-debounce.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { useMemo, useRef } from \"react\"\nimport { debounce } from \"lodash\"\n\nexport function useDebounce<T extends (...args: never[]) => void>(\n  fn: T,\n  ms: number,\n  maxWait?: number\n) {\n  const funcRef = useRef<T | null>(null)\n  funcRef.current = fn\n\n  return useMemo(\n    () =>\n      debounce(\n        (...args: Parameters<T>) => {\n          if (funcRef.current) {\n            funcRef.current(...args)\n          }\n        },\n        ms,\n        { maxWait }\n      ),\n    [ms, maxWait]\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-hooks/use-debounce.ts"
    },
    {
      "path": "registry/new-york-v4/editor/shared/invariant.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nexport function invariant(\n  cond?: boolean,\n  message?: string,\n  ...args: string[]\n): asserts cond {\n  if (cond) {\n    return\n  }\n\n  throw new Error(\n    \"Internal Lexical error: invariant() is meant to be replaced at compile \" +\n      \"time. There is no runtime version. Error: \" +\n      message\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/shared/invariant.ts"
    },
    {
      "path": "registry/new-york-v4/editor/transformers/markdown-table-transformer.ts",
      "content": "import {\n  $convertFromMarkdownString,\n  $convertToMarkdownString,\n  CHECK_LIST,\n  ELEMENT_TRANSFORMERS,\n  ElementTransformer,\n  MULTILINE_ELEMENT_TRANSFORMERS,\n  TEXT_FORMAT_TRANSFORMERS,\n  TEXT_MATCH_TRANSFORMERS,\n} from \"@lexical/markdown\"\nimport {\n  $createTableCellNode,\n  $createTableNode,\n  $createTableRowNode,\n  $isTableCellNode,\n  $isTableNode,\n  $isTableRowNode,\n  TableCellHeaderStates,\n  TableCellNode,\n  TableNode,\n  TableRowNode,\n} from \"@lexical/table\"\nimport { $isParagraphNode, $isTextNode, LexicalNode } from \"lexical\"\n\n// import { EMOJI } from \"@/registry/new-york-v4/editor/transformers/markdown-emoji-transformer\"\nimport { HR } from \"@/registry/new-york-v4/editor/transformers/markdown-hr-transformer\"\nimport { IMAGE } from \"@/registry/new-york-v4/editor/transformers/markdown-image-transformer\"\n\n// import { TWEET } from \"@/registry/new-york-v4/editor/transformers/markdown-tweet-transformer\"\n\n// Very primitive table setup\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/\n\nconst OTHER_MARKDOWN_TRANSFORMERS = [\n  HR,\n  IMAGE,\n  // EMOJI,\n  // TWEET,\n  CHECK_LIST,\n  ...ELEMENT_TRANSFORMERS,\n  ...MULTILINE_ELEMENT_TRANSFORMERS,\n  ...TEXT_FORMAT_TRANSFORMERS,\n  ...TEXT_MATCH_TRANSFORMERS,\n]\n\nexport const TABLE: ElementTransformer = {\n  dependencies: [TableNode, TableRowNode, TableCellNode],\n  export: (node: LexicalNode) => {\n    if (!$isTableNode(node)) {\n      return null\n    }\n\n    const output: string[] = []\n\n    for (const row of node.getChildren()) {\n      const rowOutput = []\n      if (!$isTableRowNode(row)) {\n        continue\n      }\n\n      let isHeaderRow = false\n      for (const cell of row.getChildren()) {\n        // It's TableCellNode so it's just to make flow happy\n        if ($isTableCellNode(cell)) {\n          rowOutput.push(\n            $convertToMarkdownString(OTHER_MARKDOWN_TRANSFORMERS, cell).replace(\n              /\\n/g,\n              \"\\\\n\"\n            )\n          )\n          if (cell.__headerState === TableCellHeaderStates.ROW) {\n            isHeaderRow = true\n          }\n        }\n      }\n\n      output.push(`| ${rowOutput.join(\" | \")} |`)\n      if (isHeaderRow) {\n        output.push(`| ${rowOutput.map((_) => \"---\").join(\" | \")} |`)\n      }\n    }\n\n    return output.join(\"\\n\")\n  },\n  regExp: TABLE_ROW_REG_EXP,\n  replace: (parentNode, _1, match) => {\n    // Header row\n    if (TABLE_ROW_DIVIDER_REG_EXP.test(match[0])) {\n      const table = parentNode.getPreviousSibling()\n      if (!table || !$isTableNode(table)) {\n        return\n      }\n\n      const rows = table.getChildren()\n      const lastRow = rows[rows.length - 1]\n      if (!lastRow || !$isTableRowNode(lastRow)) {\n        return\n      }\n\n      // Add header state to row cells\n      lastRow.getChildren().forEach((cell) => {\n        if (!$isTableCellNode(cell)) {\n          return\n        }\n        cell.setHeaderStyles(\n          TableCellHeaderStates.ROW,\n          TableCellHeaderStates.ROW\n        )\n      })\n\n      // Remove line\n      parentNode.remove()\n      return\n    }\n\n    const matchCells = mapToTableCells(match[0])\n\n    if (matchCells == null) {\n      return\n    }\n\n    const rows = [matchCells]\n    let sibling = parentNode.getPreviousSibling()\n    let maxCells = matchCells.length\n\n    while (sibling) {\n      if (!$isParagraphNode(sibling)) {\n        break\n      }\n\n      if (sibling.getChildrenSize() !== 1) {\n        break\n      }\n\n      const firstChild = sibling.getFirstChild()\n\n      if (!$isTextNode(firstChild)) {\n        break\n      }\n\n      const cells = mapToTableCells(firstChild.getTextContent())\n\n      if (cells == null) {\n        break\n      }\n\n      maxCells = Math.max(maxCells, cells.length)\n      rows.unshift(cells)\n      const previousSibling = sibling.getPreviousSibling()\n      sibling.remove()\n      sibling = previousSibling\n    }\n\n    const table = $createTableNode()\n\n    for (const cells of rows) {\n      const tableRow = $createTableRowNode()\n      table.append(tableRow)\n\n      for (let i = 0; i < maxCells; i++) {\n        tableRow.append(i < cells.length ? cells[i] : $createTableCell(\"\"))\n      }\n    }\n\n    const previousSibling = parentNode.getPreviousSibling()\n    if (\n      $isTableNode(previousSibling) &&\n      getTableColumnsSize(previousSibling) === maxCells\n    ) {\n      previousSibling.append(...table.getChildren())\n      parentNode.remove()\n    } else {\n      parentNode.replace(table)\n    }\n\n    table.selectEnd()\n  },\n  type: \"element\",\n}\n\nfunction getTableColumnsSize(table: TableNode) {\n  const row = table.getFirstChild()\n  return $isTableRowNode(row) ? row.getChildrenSize() : 0\n}\n\nconst $createTableCell = (textContent: string): TableCellNode => {\n  textContent = textContent.replace(/\\\\n/g, \"\\n\")\n  const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS)\n  $convertFromMarkdownString(textContent, OTHER_MARKDOWN_TRANSFORMERS, cell)\n  return cell\n}\n\nconst mapToTableCells = (textContent: string): Array<TableCellNode> | null => {\n  const match = textContent.match(TABLE_ROW_REG_EXP)\n  if (!match || !match[1]) {\n    return null\n  }\n  return match[1].split(\"|\").map((text) => $createTableCell(text))\n}\n",
      "type": "registry:component",
      "target": "components/editor/transformers/markdown-table-transformer.ts"
    }
  ]
}