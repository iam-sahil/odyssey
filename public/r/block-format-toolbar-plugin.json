{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "block-format-toolbar-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/list",
    "@lexical/utils",
    "@lexical/selection",
    "@lexical/code"
  ],
  "registryDependencies": [
    "select",
    "@shadcn-editor/toolbar-plugin"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format-toolbar-plugin.tsx",
      "content": "\"use client\"\n\nimport { $isListNode, ListNode } from \"@lexical/list\"\nimport { $isHeadingNode } from \"@lexical/rich-text\"\nimport { $findMatchingParent, $getNearestNodeOfType } from \"@lexical/utils\"\nimport { $isRangeSelection, $isRootOrShadowRoot, BaseSelection } from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { useUpdateToolbarHandler } from \"@/registry/new-york-v4/editor/editor-hooks/use-update-toolbar\"\nimport { blockTypeToBlockName } from \"@/registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data\"\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectTrigger,\n} from \"@/registry/new-york-v4/ui/select\"\n\nexport function BlockFormatDropDown({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const { activeEditor, blockType, setBlockType } = useToolbarContext()\n\n  function $updateToolbar(selection: BaseSelection) {\n    if ($isRangeSelection(selection)) {\n      const anchorNode = selection.anchor.getNode()\n      let element =\n        anchorNode.getKey() === \"root\"\n          ? anchorNode\n          : $findMatchingParent(anchorNode, (e) => {\n              const parent = e.getParent()\n              return parent !== null && $isRootOrShadowRoot(parent)\n            })\n\n      if (element === null) {\n        element = anchorNode.getTopLevelElementOrThrow()\n      }\n\n      const elementKey = element.getKey()\n      const elementDOM = activeEditor.getElementByKey(elementKey)\n\n      if (elementDOM !== null) {\n        // setSelectedElementKey(elementKey);\n        if ($isListNode(element)) {\n          const parentList = $getNearestNodeOfType<ListNode>(\n            anchorNode,\n            ListNode\n          )\n          const type = parentList\n            ? parentList.getListType()\n            : element.getListType()\n          setBlockType(type)\n        } else {\n          const type = $isHeadingNode(element)\n            ? element.getTag()\n            : element.getType()\n          if (type in blockTypeToBlockName) {\n            setBlockType(type as keyof typeof blockTypeToBlockName)\n          }\n        }\n      }\n    }\n  }\n\n  useUpdateToolbarHandler($updateToolbar)\n\n  return (\n    <Select\n      value={blockType}\n      onValueChange={(value) => {\n        setBlockType(value as keyof typeof blockTypeToBlockName)\n      }}\n    >\n      <SelectTrigger className=\"!h-8 w-min gap-1\">\n        {blockTypeToBlockName[blockType].icon}\n        <span>{blockTypeToBlockName[blockType].label}</span>\n      </SelectTrigger>\n      <SelectContent>\n        <SelectGroup>{children}</SelectGroup>\n      </SelectContent>\n    </Select>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format-toolbar-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-update-toolbar.ts",
      "content": "import { useEffect } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport {\n  $getSelection,\n  BaseSelection,\n  COMMAND_PRIORITY_CRITICAL,\n  SELECTION_CHANGE_COMMAND,\n} from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\n\nexport function useUpdateToolbarHandler(\n  callback: (selection: BaseSelection) => void\n) {\n  const [editor] = useLexicalComposerContext()\n  const { activeEditor } = useToolbarContext()\n\n  useEffect(() => {\n    return activeEditor.registerCommand(\n      SELECTION_CHANGE_COMMAND,\n      () => {\n        const selection = $getSelection()\n        if (selection) {\n          callback(selection)\n        }\n        return false\n      },\n      COMMAND_PRIORITY_CRITICAL\n    )\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, callback])\n\n  useEffect(() => {\n    activeEditor.getEditorState().read(() => {\n      const selection = $getSelection()\n      if (selection) {\n        callback(selection)\n      }\n    })\n  }, [activeEditor, callback])\n}\n",
      "type": "registry:hook",
      "target": "components/editor/editor-hooks/use-update-toolbar.ts"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data.tsx",
      "content": "import {\n  CodeIcon,\n  Heading1Icon,\n  Heading2Icon,\n  Heading3Icon,\n  ListIcon,\n  ListOrderedIcon,\n  ListTodoIcon,\n  QuoteIcon,\n  TextIcon,\n} from \"lucide-react\"\n\nexport const blockTypeToBlockName: Record<\n  string,\n  { label: string; icon: React.ReactNode }\n> = {\n  paragraph: {\n    label: \"Paragraph\",\n    icon: <TextIcon className=\"size-4\" />,\n  },\n  h1: {\n    label: \"Heading 1\",\n    icon: <Heading1Icon className=\"size-4\" />,\n  },\n  h2: {\n    label: \"Heading 2\",\n    icon: <Heading2Icon className=\"size-4\" />,\n  },\n  h3: {\n    label: \"Heading 3\",\n    icon: <Heading3Icon className=\"size-4\" />,\n  },\n  number: {\n    label: \"Numbered List\",\n    icon: <ListOrderedIcon className=\"size-4\" />,\n  },\n  bullet: {\n    label: \"Bulleted List\",\n    icon: <ListIcon className=\"size-4\" />,\n  },\n  check: {\n    label: \"Check List\",\n    icon: <ListTodoIcon className=\"size-4\" />,\n  },\n  code: {\n    label: \"Code Block\",\n    icon: <CodeIcon className=\"size-4\" />,\n  },\n  quote: {\n    label: \"Quote\",\n    icon: <QuoteIcon className=\"size-4\" />,\n  },\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format/block-format-data.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format/format-bulleted-list.tsx",
      "content": "import { INSERT_UNORDERED_LIST_COMMAND } from \"@lexical/list\"\nimport { $setBlocksType } from \"@lexical/selection\"\nimport { $createParagraphNode, $getSelection, $isRangeSelection } from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { blockTypeToBlockName } from \"@/registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nconst BLOCK_FORMAT_VALUE = \"bullet\"\n\nexport function FormatBulletedList() {\n  const { activeEditor, blockType } = useToolbarContext()\n\n  const formatParagraph = () => {\n    activeEditor.update(() => {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () => $createParagraphNode())\n      }\n    })\n  }\n\n  const formatBulletedList = () => {\n    if (blockType !== \"bullet\") {\n      activeEditor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined)\n    } else {\n      formatParagraph()\n    }\n  }\n\n  return (\n    <SelectItem value={BLOCK_FORMAT_VALUE} onPointerDown={formatBulletedList}>\n      <div className=\"flex items-center gap-1 font-normal\">\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].icon}\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].label}\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format/format-bulleted-list.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format/format-check-list.tsx",
      "content": "import { INSERT_CHECK_LIST_COMMAND } from \"@lexical/list\"\nimport { $setBlocksType } from \"@lexical/selection\"\nimport { $createParagraphNode, $getSelection, $isRangeSelection } from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { blockTypeToBlockName } from \"@/registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nconst BLOCK_FORMAT_VALUE = \"check\"\n\nexport function FormatCheckList() {\n  const { activeEditor, blockType } = useToolbarContext()\n\n  const formatParagraph = () => {\n    activeEditor.update(() => {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () => $createParagraphNode())\n      }\n    })\n  }\n\n  const formatCheckList = () => {\n    if (blockType !== \"number\") {\n      activeEditor.dispatchCommand(INSERT_CHECK_LIST_COMMAND, undefined)\n    } else {\n      formatParagraph()\n    }\n  }\n\n  return (\n    <SelectItem value={BLOCK_FORMAT_VALUE} onPointerDown={formatCheckList}>\n      <div className=\"flex items-center gap-1 font-normal\">\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].icon}\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].label}\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format/format-check-list.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format/format-heading.tsx",
      "content": "import { $createHeadingNode, HeadingTagType } from \"@lexical/rich-text\"\nimport { $setBlocksType } from \"@lexical/selection\"\nimport { $getSelection } from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { blockTypeToBlockName } from \"@/registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function FormatHeading({ levels = [] }: { levels: HeadingTagType[] }) {\n  const { activeEditor, blockType } = useToolbarContext()\n\n  const formatHeading = (headingSize: HeadingTagType) => {\n    if (blockType !== headingSize) {\n      activeEditor.update(() => {\n        const selection = $getSelection()\n        $setBlocksType(selection, () => $createHeadingNode(headingSize))\n      })\n    }\n  }\n\n  return levels.map((level) => (\n    <SelectItem\n      key={level}\n      value={level}\n      onPointerDown={() => formatHeading(level)}\n    >\n      <div className=\"flex items-center gap-1 font-normal\">\n        {blockTypeToBlockName[level].icon}\n        {blockTypeToBlockName[level].label}\n      </div>\n    </SelectItem>\n  ))\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format/format-heading.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format/format-numbered-list.tsx",
      "content": "import { INSERT_ORDERED_LIST_COMMAND } from \"@lexical/list\"\nimport { $setBlocksType } from \"@lexical/selection\"\nimport { $createParagraphNode, $getSelection, $isRangeSelection } from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { blockTypeToBlockName } from \"@/registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nconst BLOCK_FORMAT_VALUE = \"number\"\n\nexport function FormatNumberedList() {\n  const { activeEditor, blockType } = useToolbarContext()\n\n  const formatParagraph = () => {\n    activeEditor.update(() => {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () => $createParagraphNode())\n      }\n    })\n  }\n\n  const formatNumberedList = () => {\n    if (blockType !== \"number\") {\n      activeEditor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined)\n    } else {\n      formatParagraph()\n    }\n  }\n\n  return (\n    <SelectItem value={BLOCK_FORMAT_VALUE} onPointerDown={formatNumberedList}>\n      <div className=\"flex items-center gap-1 font-normal\">\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].icon}\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].label}\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format/format-numbered-list.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format/format-paragraph.tsx",
      "content": "import { $setBlocksType } from \"@lexical/selection\"\nimport { $createParagraphNode, $getSelection, $isRangeSelection } from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { blockTypeToBlockName } from \"@/registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nconst BLOCK_FORMAT_VALUE = \"paragraph\"\n\nexport function FormatParagraph() {\n  const { activeEditor } = useToolbarContext()\n\n  const formatParagraph = () => {\n    activeEditor.update(() => {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () => $createParagraphNode())\n      }\n    })\n  }\n\n  return (\n    <SelectItem value={BLOCK_FORMAT_VALUE} onPointerDown={formatParagraph}>\n      <div className=\"flex items-center gap-1 font-normal\">\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].icon}\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].label}\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format/format-paragraph.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-format/format-quote.tsx",
      "content": "import { $createQuoteNode } from \"@lexical/rich-text\"\nimport { $setBlocksType } from \"@lexical/selection\"\nimport { $getSelection } from \"lexical\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { blockTypeToBlockName } from \"@/registry/new-york-v4/editor/plugins/toolbar/block-format/block-format-data\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nconst BLOCK_FORMAT_VALUE = \"quote\"\n\nexport function FormatQuote() {\n  const { activeEditor, blockType } = useToolbarContext()\n\n  const formatQuote = () => {\n    if (blockType !== \"quote\") {\n      activeEditor.update(() => {\n        const selection = $getSelection()\n        $setBlocksType(selection, () => $createQuoteNode())\n      })\n    }\n  }\n\n  return (\n    <SelectItem value=\"quote\" onPointerDown={formatQuote}>\n      <div className=\"flex items-center gap-1 font-normal\">\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].icon}\n        {blockTypeToBlockName[BLOCK_FORMAT_VALUE].label}\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-format/format-quote.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/list-max-indent-level-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { useEffect } from \"react\"\nimport { $getListDepth, $isListItemNode, $isListNode } from \"@lexical/list\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport type { ElementNode, RangeSelection } from \"lexical\"\nimport {\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_CRITICAL,\n  INDENT_CONTENT_COMMAND,\n} from \"lexical\"\n\nfunction getElementNodesInSelection(\n  selection: RangeSelection\n): Set<ElementNode> {\n  const nodesInSelection = selection.getNodes()\n\n  if (nodesInSelection.length === 0) {\n    return new Set([\n      selection.anchor.getNode().getParentOrThrow(),\n      selection.focus.getNode().getParentOrThrow(),\n    ])\n  }\n\n  return new Set(\n    nodesInSelection.map((n) => ($isElementNode(n) ? n : n.getParentOrThrow()))\n  )\n}\n\nfunction $shouldPreventIndent(maxDepth: number): boolean {\n  const selection = $getSelection()\n\n  if (!$isRangeSelection(selection)) {\n    return false\n  }\n\n  const elementNodesInSelection: Set<ElementNode> =\n    getElementNodesInSelection(selection)\n\n  let totalDepth = 0\n\n  for (const elementNode of Array.from(elementNodesInSelection)) {\n    if ($isListNode(elementNode)) {\n      totalDepth = Math.max($getListDepth(elementNode) + 1, totalDepth)\n    } else if ($isListItemNode(elementNode)) {\n      const parent = elementNode.getParent()\n\n      if (!$isListNode(parent)) {\n        throw new Error(\n          \"ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.\"\n        )\n      }\n\n      totalDepth = Math.max($getListDepth(parent) + 1, totalDepth)\n    }\n  }\n\n  return totalDepth > maxDepth\n}\n\nexport function ListMaxIndentLevelPlugin({\n  maxDepth = 7,\n}: {\n  maxDepth?: number\n}): null {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand(\n      INDENT_CONTENT_COMMAND,\n      () => $shouldPreventIndent(maxDepth),\n      COMMAND_PRIORITY_CRITICAL\n    )\n  }, [editor, maxDepth])\n  return null\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/list-max-indent-level-plugin.tsx"
    }
  ]
}